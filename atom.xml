<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>berberman&#39;s Blog</title>
  
  
  <link href="https://berberman.cn/atom.xml" rel="self"/>
  
  <link href="https://berberman.cn/"/>
  <updated>2020-08-13T10:39:10.633Z</updated>
  <id>https://berberman.cn/</id>
  
  <author>
    <name>berberman</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Haskell 的几种形参</title>
    <link href="https://berberman.cn/2020/08/10/haskell-parameters/"/>
    <id>https://berberman.cn/2020/08/10/haskell-parameters/</id>
    <published>2020-08-10T18:46:10.000Z</published>
    <updated>2020-08-13T10:39:10.633Z</updated>
    
    <content type="html"><![CDATA[<p>内容很大部分来自 <a href="https://haskell.love/richard-eisenberg/" target="_blank" rel="noopener">https://haskell.love/richard-eisenberg/</a> 这一视频，奇怪的知识增加了。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">const</span> :: a -&gt; b -&gt; a</span><br><span class="line"><span class="title">const</span> x y = x</span><br></pre></td></tr></table></figure><p><code>const</code> 函数接收几个参数呢？是 <code>a</code> 类型的 <code>x</code> 与 <code>b</code> 类型的 <code>y</code> —— 两个吗？</p><p>为了便捷，GHC 默认会省略掉 rank 1 的 quantifier。我们可以打开语言扩展<br><code>ExplicitForAll</code> 并在 GHCi中开启参数 <code>-fprint-explicit-foralls</code>，以便在代码中可以显式书写量词，以及使得在 GHCi 使用 <code>:t</code> 时会同时打印出量词。当然，有了 <code>UnicodeSyntax</code> 语言扩展，<code>∀</code> 也能被 parse。所以我们可以改写一下新的 <code>const</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">const</span> :: ∀ a b . a -&gt; b -&gt; a</span><br><span class="line"><span class="title">const</span> x y = x</span><br></pre></td></tr></table></figure><p>这样就清晰多了 —— <code>const</code> 接收四个参数：类型变量 <code>a</code> 和 <code>b</code>，以及 <code>x</code> 和 <code>y</code>。有的同志<del>（用过 exteff 相关库）</del>可能知道一个叫 <code>TypeApplications</code> 的扩展，开启它之后类型变量也能显式指定，例如 <code>const @Int @String 233 &quot;QAQ&quot;</code>。这样以来我们可以更加确信 <code>const</code> 有四个参数。</p><p>再来看一个相似的例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shout</span> :: ∀ a . <span class="type">Show</span> a =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">shout</span> x = map toUpper (show x) ++ <span class="string">"!"</span></span><br></pre></td></tr></table></figure><p><code>shout</code> 接收三个参数：类型变量 <code>a</code>、类型类实例 <code>Show a</code> 以及 <code>x</code>。类型类实例有点像隐式转换，编译器会在上下文中去找这个东西，使得函数体中能够正确调用类型类约定的函数。值得注意的是和类型变量不同，类型类实例只能靠编译器推断，不能手动传进去。</p><a id="more"></a><h2 id="三类形参"><a href="#三类形参" class="headerlink" title="三类形参"></a>三类形参</h2><p>下面介绍三种形参具有的特性：<em>dependent</em>、<em>relevant</em>、<em>visible</em>。</p><ul><li><em>dependent</em> —— 这个参数是依赖的，即这个参数值的选择会影响后续参数的类型。</li><li><em>relevant</em> —— 这个参数是相关的，即这个参数值能在运行期函数体中使用。</li><li><em>visible</em> —— 这个参数是可见的，即这个参数能显式传入。</li></ul><p>这样我们可以画出一张表：</p><table><thead><tr><th></th><th>类型变量</th><th>类型类实例</th><th>常规项</th></tr></thead><tbody><tr><td><em>dependent</em></td><td>是</td><td>否</td><td>否</td></tr><tr><td><em>relevant</em></td><td>否</td><td>是</td><td>是</td></tr><tr><td><em>visible</em></td><td>否</td><td>否</td><td>是</td></tr></tbody></table><p>通过上面 <code>const</code> 与 <code>shout</code> 的例子，我们得知了：</p><ul><li><p>常规项，例如 <code>Int -&gt; ...</code> 是 <em>relevant<em>（参数就要在函数体用嘛）、</em>visible*（当然要显式传，不然怎么知道是几）并且 *non-dependent</em> 的（你 Haskell 并没有原生依赖类型）。</p></li><li><p>类型类实例，例如 <code>Show a =&gt; ...</code> 是 <em>relevant<em>（函数体调用到了类型类实例中的代码）、</em>invisible</em> （只能靠编译器找）并且 <em>non-dependent</em>  的。</p></li><li><p>类型变量，例如 <code>∀ (a :: Type). ...</code> 是 <em>irrelevant<em>、</em>invisible</em> 并且 <em>non-dependent</em> 的。</p></li></ul><p>事实上，这三类特性还有其他的组合方式，我们暂且画出一张更全的表：</p><table><thead><tr><th><em>relevant</em></th><th><em>visible</em></th><th><em>dependent</em></th><th>表示方法</th></tr></thead><tbody><tr><td>是</td><td>是</td><td>是</td><td>?????</td></tr><tr><td>是</td><td>是</td><td>否</td><td>通常项 <code>Int -&gt; ...</code></td></tr><tr><td>是</td><td>否</td><td>是</td><td>?????</td></tr><tr><td>是</td><td>否</td><td>否</td><td>类型类实例 <code>Show a =&gt; ...</code></td></tr><tr><td>否</td><td>是</td><td>是</td><td>?????</td></tr><tr><td>否</td><td>是</td><td>否</td><td><del>要你有何用！</del></td></tr><tr><td>否</td><td>否</td><td>是</td><td>类型参数 <code>∀ (a :: Type). ...</code></td></tr><tr><td>否</td><td>否</td><td>否</td><td><del>要你有何用！</del></td></tr></tbody></table><p>不要急，咱一点点来，先从 <em>relevant</em> 看起。</p><h2 id="relevant"><a href="#relevant" class="headerlink" title="relevant"></a><em>relevant</em></h2><p>看看以下 <code>id</code> 函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这段代码不能成功编译</span></span><br><span class="line"><span class="title">id</span> :: ∀ a . a -&gt; a</span><br><span class="line"><span class="title">id</span> <span class="type">True</span> = <span class="type">False</span></span><br><span class="line"><span class="title">id</span> x    = x</span><br></pre></td></tr></table></figure><p>我们尝试定义出一个奇怪的 id 函数，对于 <code>Bool</code> 类型的 <code>True</code> 会返回 <code>False</code>；而对于其他类型则原封不动地返回。好像没啥问题的说，但这段代码并<strong>不能</strong>被 GHC 编译。<code>id</code> 应适用于所有类型 <code>a</code>，但我们在第一个模式中把 <code>a</code> 特化成了 <code>Bool</code>，这是不合法的。由此可以得出 Haskell 中的类型变量是 <em>irrelevant</em> 的（至少在编译期）。但是！咱还有所谓的<strong>反射</strong>（<code>Data.Typeable</code> / <code>Type.Reflection</code>）：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">weirdID</span> :: ∀ a . <span class="type">Typeable</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">weirdID</span></span><br><span class="line">  | <span class="type">Just</span> <span class="type">HRefl</span> &lt;- typeRep @a `eqTypeRep` typeRep @<span class="type">Bool</span></span><br><span class="line">  = \<span class="keyword">case</span> <span class="type">True</span> -&gt; <span class="type">False</span></span><br><span class="line">          x    -&gt; x</span><br><span class="line">  | otherwise</span><br><span class="line">  = \x -&gt; x</span><br></pre></td></tr></table></figure><p><del>Pattern guard 语法之前没见过呢。</del> 不难看出，这里在运行期比较了 <code>a</code> 和 <code>Bool</code> 是否相等，根据比较结果来决定函数行为。<code>Typeable</code>  constraint 给了类型 Propositional equality 的能力。<code>weirdID</code> 中的 <code>a</code> 已经算是  <em>dependent &amp; relevant</em> 了，虽然有些丑陋。至于说这个组合有什么用，别问，问就是<a href="#题外话">模拟依赖类型</a>。当然，还可以像 <code>weirdID2</code> 这样显式传入 <code>TypeRep</code> 来代替 <code>Typeable</code> 约束，它们没啥本质上的区别：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">weirdID2</span> :: ∀ a . <span class="type">TypeRep</span> a -&gt; a -&gt; a</span><br><span class="line"><span class="title">weirdID2</span> req</span><br><span class="line">  | <span class="type">Just</span> <span class="type">HRefl</span> &lt;- rep `eqTypeRep` typeRep @<span class="type">Bool</span></span><br><span class="line">  = \<span class="keyword">case</span> <span class="type">True</span> -&gt; <span class="type">False</span></span><br><span class="line">          x    -&gt; x</span><br><span class="line">  | otherwise</span><br><span class="line">  = \x -&gt; x</span><br></pre></td></tr></table></figure><h2 id="visible"><a href="#visible" class="headerlink" title="visible"></a><em>visible</em></h2><p><code>weirdID</code> / <code>weirdID2</code> 中的 <code>a</code> 已经做到了 <em>dependent &amp; relevant*，那么 *visible</em> 呢？很遗憾，universal quantification <code>∀ a</code> 依然是不可见的，而我们真正想要的是 <em>VDQ</em>（<em>visible dependent quantification</em>），就像 <code>weirdID3</code> 这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这段代码不能成功编译</span></span><br><span class="line"><span class="title">weirdID3</span> :: ∀ a -&gt; <span class="type">Typeable</span> a =&gt; a -&gt; a</span><br><span class="line"><span class="title">weirdID3</span> a</span><br><span class="line">  | <span class="type">Just</span> <span class="type">HRefl</span> &lt;- typeRep a `eqTypeRep` typeRep @<span class="type">Bool</span></span><br><span class="line">  = \<span class="keyword">case</span> <span class="type">True</span> -&gt; <span class="type">False</span></span><br><span class="line">          x    -&gt; x</span><br><span class="line">  | otherwise</span><br><span class="line">  = \x -&gt; x</span><br></pre></td></tr></table></figure><p>这里的 <code>∀ a.</code> 变成了 <code>∀ a -&gt;</code>，意味着 <code>∀ a</code> 从一个 Scheme（在 universal quantifier 约束下的 polymorphic type variable）变成了一个 <em>dependent</em> term。</p><p>只不过 —— 编译这段代码，你会得到 <strong>Illegal visible, dependent quantification in the type of a term: forall a -&gt; Typeable a =&gt; a -&gt; a (GHC does not yet support this)</strong>（<del>这波啊，这波是 GHC 布星</del></p><p>既然 Term 层不行，咱来 Kind 层实现：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">WeirdId3</span> :: ∀ a -&gt; a -&gt; a <span class="comment">-- 需要打开 StandaloneKindSignatures</span></span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="keyword">family</span> <span class="type">WeirdId3</span> a x where</span></span><br><span class="line">  <span class="type">WeirdId3</span> <span class="type">Bool</span> <span class="type">True</span> = <span class="type">False</span></span><br><span class="line">  <span class="type">WeirdId3</span> _    x    = x</span><br></pre></td></tr></table></figure><p>唔姆，类型家族很好理解，就是定义一个操作类型的函数。在 GHCi 中运行 <code>:k WeirdId3 Bool True</code> 可以得到 <code>&#39;False</code>。注意这个 <code>&#39;</code> —— 咱运算得出的结果是一个类型，<code>&#39;False</code> 的 kind 是 <code>Bool</code>。类似，运行 <code>WeirdId3 Symbol &quot;hello&quot;</code> 可以得到 <code>&quot;hello&quot;</code>，当然这个 <code>&quot;hello&quot;</code> 不是 <code>String</code> 的实例，而是 kind 为 <code>Symbol</code> 的一个类型。所有在 Kind Level 进行 quantification 的类型变量都是 <em>relevant</em> 的，这是 GHC 钦定的。换句话说，咱写不出来类型家族 <code>WeirdId3 :: ∀ a. a -&gt; a</code>，而且调用 <code>WeirdId _ x</code> 时 <code>_</code> 必须写上 <code>x</code> 的类型。</p><p>好像完事了，来把表填上：</p><table><thead><tr><th><em>relevant</em></th><th><em>visible</em></th><th><em>dependent</em></th><th>表示方法</th></tr></thead><tbody><tr><td>是</td><td>是</td><td>是</td><td>Typeable VDQ： <code>∀ a -&gt; Typeable a =&gt; ...</code>（GHC 现在不支持）<br />类型层 VDQ：<code>∀ a -&gt; ...</code></td></tr><tr><td>是</td><td>是</td><td>否</td><td>通常项： <code>Int -&gt; ...</code><br />类型层：<code>ℕ -&gt; ...</code></td></tr><tr><td>是</td><td>否</td><td>是</td><td>有 Typeable 约束的类型参数 <code>∀ a . Typeable a =&gt;</code>（恶星）<br />类型层：<code>∀ a . ...</code></td></tr><tr><td>是</td><td>否</td><td>否</td><td>类型类实例 <code>Show a =&gt; ...</code></td></tr><tr><td>否</td><td>是</td><td>是</td><td>VDQ：<code>∀ a -&gt; ...</code>（GHC 现在不支持 <del>因为已经钦定了</del>）</td></tr><tr><td>否</td><td>是</td><td>否</td><td><del>要你有何用！</del></td></tr><tr><td>否</td><td>否</td><td>是</td><td>类型参数 <code>∀ (a :: Type). ...</code></td></tr><tr><td>否</td><td>否</td><td>否</td><td><del>要你有何用！</del></td></tr></tbody></table><p>看到这儿相信大家应该能理解 <code>∀ a. ...</code> 和 <code>∀ a -&gt; ...</code> 的区别吧……</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>看这个 <code>Vec</code>（Indexed datatype）：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> ℕ = <span class="type">Z</span> | <span class="type">S</span> ℕ</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vec</span> n a where</span></span><br><span class="line">  <span class="type">Nil</span> :: <span class="type">Vec</span> <span class="type">Z</span> a</span><br><span class="line">  (∶) :: a -&gt; <span class="type">Vec</span> n a -&gt; <span class="type">Vec</span> (<span class="type">S</span> n) a</span><br><span class="line"></span><br><span class="line"><span class="title">vReplicate</span> :: ∀ (n :: ℕ) a . <span class="type">Typeable</span> n =&gt; a -&gt; <span class="type">Vec</span> n a</span><br><span class="line"><span class="title">vReplicate</span> x</span><br><span class="line">  | <span class="type">Just</span> <span class="type">HRefl</span> &lt;- typeRep @n `eqTypeRep`typeRep @<span class="type">Z</span></span><br><span class="line">  = <span class="type">Nil</span></span><br><span class="line">  | <span class="type">App</span> succ m &lt;- typeRep @n</span><br><span class="line">  , <span class="type">Just</span> <span class="type">HRef</span>; &lt;- succ `eqTypeRep` typeRep @<span class="type">S</span></span><br><span class="line">  = x ∶ withTypeable n (vReplicate x)</span><br><span class="line">  | otherwise</span><br><span class="line">  = error <span class="string">"impossible"</span></span><br></pre></td></tr></table></figure><p>对于 <code>vReplicate</code> 而言，长度 <code>n</code>（类型变量）既是 <em>relevant</em> 的又是 <em>dependent</em> 的，因为这个函数要根据 <code>n</code> 来确定生成多长的 <code>Vec</code>，同时 <code>Vec</code> 的类型也依赖它的长度。事实上现在咱们还没法使用 <code>ℕ</code> 进行运算。首先，它是个 Type，咱们需要 type family 来定义操作 <code>ℕ</code>。其次，有了 type family 后它也只能出现在类型签名里或者像 <code>vReplicate</code> 这样通过 <code>Typeable</code> 强行让 <code>n</code> 变得 <em>relevant</em>，不能直接在模式匹配中使用。强制 <code>Typeable</code> 是很恶星的，把事情都搞到了 runtime，还弱化了类型系统的表达能力。关于更好地在 Haskell 中使用这种索引数据类型，可以康康 <a href="https://hackage.haskell.org/package/singletons" target="_blank" rel="noopener">singleton</a>，顺便做一下 Codewars 上那道题（</p><h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><ul><li><p><a href="https://github.com/goldfirere/ghc-proposals/blob/pi/proposals/0000-pi.rst" target="_blank" rel="noopener">Quantifiers for Dependent Haskell</a></p></li><li><p><a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst" target="_blank" rel="noopener">Linear Types</a>（在 GHC 9.0 就能用啦~）</p></li><li><p><a href="https://www.codewars.com/kata/54750ed320c64c64e20002e2" target="_blank" rel="noopener">Codewars Singletons</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;内容很大部分来自 &lt;a href=&quot;https://haskell.love/richard-eisenberg/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://haskell.love/richard-eisenberg/&lt;/a&gt; 这一视频，奇怪的知识增加了。&lt;/p&gt;
&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;const&lt;/span&gt; :: a -&amp;gt; b -&amp;gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;const&lt;/span&gt; x y = x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 函数接收几个参数呢？是 &lt;code&gt;a&lt;/code&gt; 类型的 &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 类型的 &lt;code&gt;y&lt;/code&gt; —— 两个吗？&lt;/p&gt;
&lt;p&gt;为了便捷，GHC 默认会省略掉 rank 1 的 quantifier。我们可以打开语言扩展&lt;br&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt; 并在 GHCi中开启参数 &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;，以便在代码中可以显式书写量词，以及使得在 GHCi 使用 &lt;code&gt;:t&lt;/code&gt; 时会同时打印出量词。当然，有了 &lt;code&gt;UnicodeSyntax&lt;/code&gt; 语言扩展，&lt;code&gt;∀&lt;/code&gt; 也能被 parse。所以我们可以改写一下新的 &lt;code&gt;const&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;const&lt;/span&gt; :: ∀ a b . a -&amp;gt; b -&amp;gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;const&lt;/span&gt; x y = x&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样就清晰多了 —— &lt;code&gt;const&lt;/code&gt; 接收四个参数：类型变量 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，以及 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt;。有的同志&lt;del&gt;（用过 exteff 相关库）&lt;/del&gt;可能知道一个叫 &lt;code&gt;TypeApplications&lt;/code&gt; 的扩展，开启它之后类型变量也能显式指定，例如 &lt;code&gt;const @Int @String 233 &amp;quot;QAQ&amp;quot;&lt;/code&gt;。这样以来我们可以更加确信 &lt;code&gt;const&lt;/code&gt; 有四个参数。&lt;/p&gt;
&lt;p&gt;再来看一个相似的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;shout&lt;/span&gt; :: ∀ a . &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt; a =&amp;gt; a -&amp;gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;shout&lt;/span&gt; x = map toUpper (show x) ++ &lt;span class=&quot;string&quot;&gt;&quot;!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;shout&lt;/code&gt; 接收三个参数：类型变量 &lt;code&gt;a&lt;/code&gt;、类型类实例 &lt;code&gt;Show a&lt;/code&gt; 以及 &lt;code&gt;x&lt;/code&gt;。类型类实例有点像隐式转换，编译器会在上下文中去找这个东西，使得函数体中能够正确调用类型类约定的函数。值得注意的是和类型变量不同，类型类实例只能靠编译器推断，不能手动传进去。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://berberman.cn/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>【译】 Continuation Monad</title>
    <link href="https://berberman.cn/2020/05/15/the-continuation-monad/"/>
    <id>https://berberman.cn/2020/05/15/the-continuation-monad/</id>
    <published>2020-05-15T17:30:07.000Z</published>
    <updated>2020-08-13T10:39:10.633Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<br><a href="http://www.haskellforall.com/2012/12/the-continuation-monad.html" target="_blank" rel="noopener">Gabriel Gonzalez, Sunday, December 30, 2012, Haskell for all</a><br><del>入门级文章</del> 可能算不上</p><p>续体单子是最不受欢迎的单子之一，在这篇文章中我希望能够鼓励大家去使用它。文章会从续体的整体概念和作为单子具有的特性来展开。</p><a id="more"></a><h2 id="续体"><a href="#续体" class="headerlink" title="续体"></a>续体</h2><p>Haskell 续体具有以下类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Cont</span> r a = <span class="type">Cont</span> &#123; <span class="title">runCont</span> :: ( <span class="title">a</span> -&gt; <span class="title">r</span> ) -&gt; <span class="title">r</span> &#125;</span></span><br></pre></td></tr></table></figure><p>一个续体会接收一个 <code>(a -&gt; r)</code> 的函数，并生成 <code>r</code>（可能是固定的值，像 <code>Int</code> 或 <code>IO ()</code>）。</p><p>举个例子，我可能会编写一个长时间运行的程序，每当用户输入一行输入时就会产生一个动作：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">onInput</span> :: (<span class="type">String</span> -&gt; <span class="type">IO</span> ()) -&gt; <span class="type">IO</span> ()</span><br><span class="line">        <span class="comment">-- 即 Cont (IO ()) String</span></span><br><span class="line"><span class="title">onInput</span> f = forever $ <span class="keyword">do</span></span><br><span class="line">    str &lt;- getLine</span><br><span class="line">    f str</span><br></pre></td></tr></table></figure><p>如果你曾经使用过涉及回调的框架，你会对这种写法感到熟悉。我们提供给框架一个函数（或者说一个续体），框架会使用这个函数来完成它的工作。</p><h2 id="“稍后完成我”"><a href="#“稍后完成我”" class="headerlink" title="“稍后完成我”"></a>“稍后完成我”</h2><p>在使用续体编写程序时，通常会交给别人来完成它。常见原因包括：</p><ul><li>你正在编程框架使用了用户提供的回调</li><li>你正在为游戏玩家定义一个供他们定制的地图引擎</li><li>你很懒</li></ul><p>我将使用下面假设的代码段作为例子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">unitAttack</span> target = <span class="keyword">do</span></span><br><span class="line">    swingAxeBack <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> ??? target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>假设你必须打包并编译这段代码，供其他人（比如说你的同事）以后使用，但是它还不能编译，因为你还有未确定的 <code>???</code> 函数。你会怎么办？</p><p>像所有好的程序一样，最好的解决方案是最懒惰的。我们将不完整的行为作为一个参数，以便稍后完成函数的人可以通过将特定的行为传入来完成函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; (<span class="type">Target</span> -&gt; <span class="type">IO</span> ()) -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">unitAttack</span> target todo = <span class="keyword">do</span></span><br><span class="line">    swingAxeBack <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> todo target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>问题解决！注意，右手边的类型签名和我们的 <code>Cont</code> 类型非常相似。我们可以把它包装进 <code>Cont</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; <span class="type">Cont</span> (<span class="type">IO</span> ()) <span class="type">Target</span></span><br><span class="line"><span class="title">unitAttack</span> target = <span class="type">Cont</span> $ \todo -&gt; <span class="keyword">do</span></span><br><span class="line">    swingAxeBack <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> todo target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>……或者，更好的是，我们可以使用 <code>ContT</code> 来替代。它的好处在于它是一个单子变换器，可以更加方便。<code>ContT</code> 和 <code>Cont</code> 具有相同的 <code>Monad</code> 实例，所以它们可以相互替换：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ContT</span> r m a = <span class="type">ContT</span> &#123; <span class="title">runContT</span> :: (<span class="title">a</span> -&gt; <span class="title">m</span> <span class="title">r</span>) -&gt; <span class="title">m</span> <span class="title">r</span> &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Target</span></span><br><span class="line"><span class="title">unitAttack</span> target = <span class="type">ContT</span> $ \todo -&gt; <span class="keyword">do</span></span><br><span class="line">    swingAxeBack <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> todo target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>这非常妙，因为现在其他人可以从我们停下的地方延续了（因此得名：续体）。他们只需定义出缺少的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">damageTarget</span> :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure><p>并把它提供给我们的续体去完成。</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>当我们的函数中仅有一个洞时这个策略十分有效，但如果我们的函数中有两个洞，并且他们需要不同的参数呢？</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">unitAttack</span> target = <span class="keyword">do</span></span><br><span class="line">    ???_1 <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> ???_2 target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>好吧，我们可以试着接受两个续体：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span></span><br><span class="line"> :: <span class="type">Target</span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">IO</span> ()) -&gt; (<span class="type">Target</span> -&gt; <span class="type">IO</span> ()) -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">unitAttack</span> target todo1 todo2 = <span class="keyword">do</span></span><br><span class="line">    todo1 <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> todo2 target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>……不过这就不再完好地适合我们的 <code>Cont</code> 类型了，它只需一个续体。</p><p>幸运的是，有一个清爽并且通用的解决方案。只需定义一个数据类型，将两种可能的参数使用和类型包装起来，并定义一个接收这个和类型的续体：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Hole</span> = <span class="type">Swing</span> <span class="type">Int</span> | <span class="type">Attack</span> <span class="type">Target</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Hole</span></span><br><span class="line"><span class="title">unitAttack</span> target = <span class="type">ContT</span> $ \k -&gt; <span class="keyword">do</span></span><br><span class="line">    k (<span class="type">Swing</span> <span class="number">60</span>)</span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> k (<span class="type">Attack</span> target)</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>每个构造子像是一个占位符，告诉续体正在填的是哪个洞。然后其他人可以从我们停止的地方延续，只需写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">damage</span>    :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">swingBack</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"></span><br><span class="line"><span class="title">continue</span> :: <span class="type">Hole</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">continue</span> (<span class="type">Swing</span>  n) = swingBack n</span><br><span class="line"><span class="title">continue</span> (<span class="type">Attack</span> t) = damage t</span><br><span class="line"></span><br><span class="line"><span class="title">runContT</span> (unitAttack target) continue :: <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure><p>这个技巧可以推广到 <code>n</code> 个洞，每个洞都有可变参数。只需定义有 <code>n</code> 个构造子的类型，让每个洞都有一个构造子，并在构造子中储存特定续体所需的参数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Hole</span> = <span class="type">Hole1</span> <span class="type">Arg1</span> <span class="type">Arg2</span> | <span class="type">Hole2</span> | <span class="type">Hole3</span> <span class="type">Arg3</span> | <span class="type">Hole4</span></span></span><br></pre></td></tr></table></figure><h2 id="代数数据类型"><a href="#代数数据类型" class="headerlink" title="代数数据类型"></a>代数数据类型</h2><p>歪个题，我想稍微说说代数数据类型。如果你不感兴趣的话，可以跳到下一节。事实证明，我们可以很好地推导出上述应用在多个洞的技巧。类型代数告诉我们，可以把下面的类型构造子转换成代数运算符，并从简单的代数操作中得到等价的类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Either</span> a b  &lt;=&gt;  a + b</span><br><span class="line">(a, b)      &lt;=&gt;  a * b</span><br><span class="line"><span class="title">a</span> -&gt; b      &lt;=&gt;  b ^ a</span><br></pre></td></tr></table></figure><p>这意味着如果我们有一个带着两个续体的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a1 -&gt; r) -&gt; ((a2 -&gt; r) -&gt; r)</span><br></pre></td></tr></table></figure><p>……我们可以把它翻译成等价的代数表达式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(r ^ (r ^ a2)) ^ (r ^ a1)</span><br></pre></td></tr></table></figure><p>……之后使用代数运算法则得到等价的表示：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  (r ^ (r ^ a2)) ^ (r ^ a1)</span><br><span class="line">= r ^ ((r ^ a2) * (r ^ a1))</span><br><span class="line">= r ^ (r ^ (a2 + a1))</span><br></pre></td></tr></table></figure><p>……再把它换回等价的类型，可得：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Either</span> a2 a1 -&gt; r) -&gt; r</span><br></pre></td></tr></table></figure><p>……这正是在前一节中我们所说的技巧。</p><p>相似地，如果我们有一个多参数的续体：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a -&gt; b -&gt; r) -&gt; r</span><br></pre></td></tr></table></figure><p>……我们可以使用类型代数运算得到等价的单参形式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  r ^ ((r ^ a) ^ b)</span><br><span class="line">= r ^ (r ^ (a * b))</span><br></pre></td></tr></table></figure><p>……转回去就是：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a, b) -&gt; r) -&gt; r</span><br></pre></td></tr></table></figure><h2 id="续体单子"><a href="#续体单子" class="headerlink" title="续体单子"></a>续体单子</h2><p>目前为止，我们已经解释了续体的用途，但还没解释单子的。</p><p>我坚信通往 <code>Monad</code> 的核心是理解 Kleisli 箭头，如果你想研究单子的目的或者动机，你需要先搞清楚 Kleisli 箭头干了什么。</p><p>与其研究 <code>Cont</code> 的 <code>Monad</code> 实例，不如先看看 <code>Cont</code> 上的 Kleisli 箭头长什么样，并从类型层面推断一下它的作用：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  a -&gt; <span class="type">Cont</span> r b</span><br><span class="line">~ a -&gt; (b -&gt; r) -&gt; r    <span class="comment">-- 展开 Cont 的定义</span></span><br><span class="line">~ (b -&gt; r) -&gt; (a -&gt; r)  <span class="comment">-- 翻转参数</span></span><br></pre></td></tr></table></figure><p>换句话说，我们拿到一个处理 <code>a</code> 的函数并将它变换为处理 <code>b</code> 的。</p><p>这表明了续体单子的一个最初的基本直觉：我们在变换处理器（Handler）。</p><p>让我们回顾一下之前的例子来建立这种直觉：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span> :: <span class="type">Target</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Target</span></span><br><span class="line"><span class="title">unitAttack</span> target = <span class="type">ContT</span> $ \todo -&gt; <span class="keyword">do</span></span><br><span class="line">    swingBack <span class="number">60</span></span><br><span class="line">    valid &lt;- isTargetValid target</span><br><span class="line">    <span class="keyword">if</span> valid</span><br><span class="line">    <span class="keyword">then</span> todo target</span><br><span class="line">    <span class="keyword">else</span> sayUhOh</span><br></pre></td></tr></table></figure><p>我们需要的完成函数的类型为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">handler</span> :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure><p>我们<em>可以</em> 完成这个函数 …… 或者中途放弃：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halfAssedCompletion</span> :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">halfAssedCompletion</span> target = <span class="keyword">do</span></span><br><span class="line">    registerUnitBeingAttacked</span><br><span class="line">    playDamageSound</span><br><span class="line">    ??? <span class="number">40</span>  <span class="comment">-- 快接近了……</span></span><br></pre></td></tr></table></figure><p>这意味着本质上我们创建了一个新的延续，带着稍微小一点的洞：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halfAssedCompletion</span> :: <span class="type">Target</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Int</span></span><br><span class="line"><span class="title">halfAssedCompletion</span> target = <span class="type">ContT</span> $ \todo -&gt; <span class="keyword">do</span></span><br><span class="line">    registerUnitBeingAttacked</span><br><span class="line">    playDamageSound</span><br><span class="line">    todo <span class="number">40</span></span><br></pre></td></tr></table></figure><p>这就是一个 Kleisli 箭头！这也意味着我们可以用它和上一个 Kleisli 箭头组合：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unitAttack</span> &gt;=&gt; halfAssedCompletion :: <span class="type">Target</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>这个组合把 <code>unitAttack</code> 函数代入了我们在 <code>halfAssedCompletion</code> 中留下的每个洞。然而，<code>halfAssedCompletion</code> 留下了更小的 <code>Int</code> 洞，其他人现在需要完成它。</p><p>注意，我们原来需要的处理器类型为：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">handler</span> :: <span class="type">Target</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure><p>……但现在，我们只需更小的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">newHandler</span> :: <span class="type">Int</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure><p>……换句话说，<code>halfAssedCompletion</code> 作为一个中间者，将 <code>(Int -&gt; IO ())</code> 类型的处理器变换为 <code>(Target -&gt; IO ())</code>。</p><p><code>Cont</code> 单子就是把这些各种部分完成的操作串在一起，直到所有的洞在最后都被填上。你可以使用这个抽象分阶段地完成一个项目，并在完成项目前维护者变更时能够无缝将工作交给另一个人。或者，你可以使用它将一个框架的回调 API 压缩至单个入口点。</p><h2 id="Kleisli-范畴"><a href="#Kleisli-范畴" class="headerlink" title="Kleisli 范畴"></a>Kleisli 范畴</h2><p>先前我说过单子的核心是它的 Kleisli 箭头。原因在于 Kleisli 箭头是 Kleisli 范畴中的态射，其中 <code>(&gt;=&gt;)</code> 是 Kleisli 箭头的组合：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&gt;=&gt;) :: (<span class="type">Monad</span> m) =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span><br><span class="line">(f &gt;=&gt; g) x = f x &gt;&gt;= g</span><br></pre></td></tr></table></figure><p>…… <code>return</code> 是单位元：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">return</span> :: (<span class="type">Monad</span> m) =&gt; a -&gt; m a</span><br></pre></td></tr></table></figure><p>如同所有范畴，Kleisli 范畴同样必须遵守范畴定律：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">return</span> &gt;=&gt; f = f                   <span class="comment">-- 左单位元</span></span><br><span class="line"></span><br><span class="line"><span class="title">f</span> &gt;=&gt; return = f                   <span class="comment">-- 右单位元</span></span><br><span class="line"></span><br><span class="line">(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h)  <span class="comment">-- 结合律</span></span><br></pre></td></tr></table></figure><p>遵守这些定律带来了很好的性质。举个例子，它保证你可以独立推导出在组合链中的每一个 Kleisli 箭头。每个 Kleisli 箭头的行为完全取决于它的输入（域）和输出（陪域）。那么让我们来想想模块化是如何转化为 <code>Cont</code> Kleisli 范畴的。</p><p>当变更维护者时，你不需要像这样给下一个维护者一堆遍布大量代码的洞：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">largeProgram</span> = <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line">    x &lt;- ???_1 y</span><br><span class="line">    ...</span><br><span class="line">    ???_2 horseTheyRodeInOn</span><br><span class="line">    ...</span><br><span class="line">    spawn ???_29 foo</span><br></pre></td></tr></table></figure><p>取而代之的是，你可以使用一个回调来统一所有的洞，这个回调接收单个类型（陪域）：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">largeProgram</span> :: () -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Hole</span></span><br><span class="line"><span class="title">largeProgram</span> () = <span class="type">ContT</span> $ \k -&gt; <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line">    x &lt;- k (<span class="type">Hole1</span> y)</span><br><span class="line">    ...</span><br><span class="line">    k <span class="type">Hole2</span></span><br><span class="line">    ...</span><br><span class="line">    k (<span class="type">Hole29</span> spawn foo)</span><br></pre></td></tr></table></figure><p>这给下一个人一个单入口点去延续，因为他们现在只需要写一个 Kleisli 箭头来处理 <code>Hole</code>，其中包括以前所有的洞：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nextContribution</span> :: <span class="type">Hole</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">NextHole</span></span><br><span class="line"><span class="title">nextContribution</span> currHole = <span class="type">ConT</span> $ \nextHole -&gt; <span class="keyword">case</span> currHole <span class="keyword">of</span></span><br><span class="line">    <span class="type">Hole1</span> y -&gt; ... <span class="comment">-- 填第一个洞</span></span><br><span class="line">    <span class="type">Hole2</span>   -&gt; ... <span class="comment">-- 填第二个洞</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Hole29</span> spawn foo -&gt; ... <span class="comment">-- 填第二十九个洞</span></span><br></pre></td></tr></table></figure><p>然后只需使用 Kleisli 组合连接你的代码贡献：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">largeProgram</span> &gt;=&gt; nextContribution</span><br></pre></td></tr></table></figure><p>这清晰地模块化了第一个人的贡献，后续的贡献也可以被分隔开来。通过重复这个过程，每个后续的代码贡献保持模块化，成为可组合的 Kleisli 箭头，和其他贡献清楚地分开：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">alice'sWork</span> :: a -&gt; <span class="type">ContT</span> r m b </span><br><span class="line"><span class="title">bob'sWork</span>   :: b -&gt; <span class="type">ContT</span> r m c</span><br><span class="line"><span class="title">carlo'sWork</span> :: c -&gt; <span class="type">ContT</span> r m d </span><br><span class="line"></span><br><span class="line"><span class="title">engine</span> = alice'sWork &gt;=&gt; bob'sWork &gt;=&gt; carlo'sWork :: a -&gt; <span class="type">ContT</span> r m d</span><br><span class="line"></span><br><span class="line"><span class="title">customMap</span> :: d -&gt; <span class="type">ContT</span> r m e</span><br><span class="line"></span><br><span class="line"><span class="title">completeGame</span> = engine &gt;=&gt; customMap :: a -&gt; <span class="type">ContT</span> r m e</span><br></pre></td></tr></table></figure><p>这就是为什么框架和游戏自定义地图制作者使用续体来作为公司代码和用户代码之间接口，分隔代码。续体单子可以建立严密的代码边界，包括在项目内部以及面向用户的外部 API。在把贡献代码分隔成 Kleisli 箭头的同时也分隔了每部分的职责。</p><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>框架是分离职责的典型例子，其中框架作者提供了一些代码，但是用户需要用自己的回调来填补空白。这通常会导致在使用一些框架时出现回调地狱，Node.js 就是其中将该原则发挥极致的一个。</p><p>但是并非一定如此。续体单子告诉我们一个遍布回调的庞大 API 总是可以压缩成一个单回调单参数的。更好的是，我们得到了用于组合多层回调的单子语法糖。</p><p>我会用 <code>GLUT</code> 作为一个例子，它需要一些像这样的回调：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">ReshapeCallback</span> = <span class="type">Size</span> -&gt; <span class="type">IO</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">VisibilityCallback</span> = <span class="type">Visibility</span> -&gt; <span class="type">IO</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">WindowStateCallback</span> = <span class="type">WindowState</span> -&gt; <span class="type">IO</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">CloseCallback</span> = <span class="type">IO</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还有好多，但先止步于此</span></span><br></pre></td></tr></table></figure><p>相反地是，我们可以把 GLUT 的多个回调包装进一个规范的 <code>ConT</code> API：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">glut</span> :: () -&gt; <span class="type">ContT</span> () <span class="type">IO</span> <span class="type">Hole</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Hole</span></span></span><br><span class="line">   = <span class="type">Reshape</span> <span class="type">Size</span></span><br><span class="line">   | <span class="type">Visible</span> <span class="type">Visibility</span></span><br><span class="line">   | <span class="type">Window</span> <span class="type">WindowState</span></span><br><span class="line">   | <span class="type">Close</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>现在末端用户仅有单个 GLUT 单子的入口点，因此他们只需在单个函数中完成框架：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">userCallbacks</span> :: <span class="type">Hole</span> -&gt; <span class="type">ContT</span> () <span class="type">IO</span> a</span><br><span class="line"><span class="title">userCallbacks</span> hole = <span class="type">ContT</span> $ \_ -&gt; <span class="keyword">case</span> hole <span class="keyword">of</span></span><br><span class="line">    <span class="type">Reshape</span> size -&gt; ... <span class="comment">-- 重塑形状回调</span></span><br><span class="line">    <span class="type">Visibility</span> v -&gt; ... <span class="comment">-- 可见性改变回调</span></span><br><span class="line">    <span class="type">Window</span> ws    -&gt; ... <span class="comment">-- 窗口状态改变回调</span></span><br><span class="line">    <span class="type">Close</span>        -&gt; ... <span class="comment">-- 窗口关闭回调</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>此外，他们现在可以将代码组合到 glut 框架：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">glut</span> &gt;=&gt; userCallbacks :: () -&gt; <span class="type">ContT</span> () <span class="type">IO</span> a</span><br></pre></td></tr></table></figure><h2 id="止步于此"><a href="#止步于此" class="headerlink" title="止步于此"></a>止步于此</h2><p>我们如何知道续体已经完成，并且没有后续了呢？让我们看看在没有更多的洞，并且不使用续体的情况下编译器推出的类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">let</span> done = <span class="type">ContT</span> $ \_ -&gt; return ()</span><br><span class="line">&gt;&gt;&gt; :t done</span><br><span class="line"><span class="title">done</span> :: <span class="type">Monad</span> m =&gt; <span class="type">ContT</span> () m a</span><br></pre></td></tr></table></figure><p>返回类型是多态的，意味着没有留下未填的洞了。上述函数只是在所有洞里填上了 <code>return ()</code>。我们也可以证明如果最终返回结果的类型是 <code>Void</code>，空类型，续体链也是完成的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">absurd</span> :: <span class="type">Void</span> -&gt; a  <span class="comment">-- 来自 "void" 包</span></span><br><span class="line"></span><br><span class="line"><span class="title">run</span> :: (<span class="type">Monad</span> m) =&gt; <span class="type">ContT</span> r m <span class="type">Void</span> -&gt; m r</span><br><span class="line"><span class="title">run</span> c = runContT c absurd</span><br></pre></td></tr></table></figure><p><code>run</code> 只接收完成，没有洞的程序。我们可以在上个 GLUT 例子中使用 <code>run</code>，因为最终的用户回调处理器没有留下未完成的洞：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">run</span> ((glut &gt;=&gt; userCallbacks) ()) :: <span class="type">IO</span> ()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望这篇文章能够激励人们去使用续体单子来构造和模块化代码完成的边界。续体单子在程序员尝试把一个回调地狱抽象成简单、统一、单个入口的干净接口时很自然地出现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文：&lt;br&gt;&lt;a href=&quot;http://www.haskellforall.com/2012/12/the-continuation-monad.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gabriel Gonzalez, Sunday, December 30, 2012, Haskell for all&lt;/a&gt;&lt;br&gt;&lt;del&gt;入门级文章&lt;/del&gt; 可能算不上&lt;/p&gt;
&lt;p&gt;续体单子是最不受欢迎的单子之一，在这篇文章中我希望能够鼓励大家去使用它。文章会从续体的整体概念和作为单子具有的特性来展开。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://berberman.cn/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>【译】类型家族与精灵宝可梦</title>
    <link href="https://berberman.cn/2020/02/11/type-families-and-pokemon/"/>
    <id>https://berberman.cn/2020/02/11/type-families-and-pokemon/</id>
    <published>2020-02-11T11:52:28.000Z</published>
    <updated>2020-08-13T10:39:10.633Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<br><a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon" target="_blank" rel="noopener">nubis, 16 Mar 2013, School of Haskell</a></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在我开始学 haskell 时有些不知所措。最初我把它用于一个实际的工作项目，然后我发现几乎所有的库都使用了仅在 GHC 可用的语言扩展。这让我开始有点失望，毕竟，谁想使用一种如此贫瘠的语言，以至于你需要依靠一个编译器的扩展才能实际去应用它，对吧？</p><p>好吧，我振作起来，决定学习所有这些扩展。我发现 Haskell 社区有三个热门话题，它们都在说有关 GADT、类型家族和依赖函数类似的问题。于是我试着查找资料去了解它们，但我只能找到描述它们是什么、如何使用的文章，没有一篇真正地解释为什么我们是怎么需要它们的！因此，我决定用一个友好的例子来写这篇教程，解释我们为什么需要类型家族。</p><a id="more"></a><h2 id="来吧，我们开始"><a href="#来吧，我们开始" class="headerlink" title="来吧，我们开始"></a>来吧，我们开始</h2><p>听说过精灵宝可梦吗？它们是居住在精灵宝可梦世界的奇妙生物，像是有超能力的动物。所有宝可梦有一种类型——它们的能力取决于它们的类型。举个例子，火属性的宝可梦可以喷火，水属性的宝可梦可以射出水柱。</p><p>人们可以拥有宝可梦，它们的特殊能力可以很好地在生产中利用。但是有些人仅仅把他们的宝可梦与其他人的用来战斗，这些人们自称宝可梦训练家。这些起来可能有点残忍，不过很有趣。似乎每个人都同意，包括宝可梦它们自己。精灵宝可梦世界的人们似乎也可以接受10岁的孩子离家去，冒着生命危险成为最好的宝可梦训练家，这是前所未有的。</p><p>我们将使用 Haskell 来表达精灵宝可梦世界中一个受限制的部分（有些魔改，粉丝们请原谅）：</p><ul><li>宝可梦拥有一种类型，在例子中我们仅限于<strong>火</strong>、<strong>水</strong>和<strong>草</strong>。</li><li>每种类型有三只宝可梦：小火龙、火恐龙、喷火龙为火属性；杰尼龟、卡咪龟、水箭龟为水属性；妙蛙种子、妙蛙草、妙蛙花为水属性。</li><li>每种类型有自己独特的能力（moves）：水属性执行水能力、火属性执行火能力、草属性执行草能力。</li><li>在战斗时：火属性宝可梦总会击败草属性宝可梦、草属性宝可梦总会击败水属性宝可梦、水属性宝可梦总会击败火属性宝可梦。</li><li>两个同类型的宝可梦不可战斗，因为没法决定谁会赢。</li><li>其他人可以在别的模块中添加他们自己的宝可梦。</li><li>类型检查器帮助我们严格遵循这些规则。</li></ul><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><p>首先，我们将尝试在不使用类型类和类型家族的情况下实现这些规则。</p><p>我们从一些类型的宝可梦和它们的独特能力开始，将它们分开定义有助于我们知道哪些能力与哪些宝可梦匹配。为此，我们定义了一个为宝可梦选择能力的函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span> <span class="comment">-- 宝可梦名字</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FireMove</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span> <span class="comment">-- 宝可梦能力</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">WaterMove</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">GrassMove</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">pickFireMove</span> :: <span class="type">Fire</span> -&gt; <span class="type">FireMove</span></span><br><span class="line"><span class="title">pickFireMove</span> <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line"><span class="title">pickFireMove</span> <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line"><span class="title">pickFireMove</span> <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="title">pickWaterMove</span> :: <span class="type">Water</span> -&gt; <span class="type">WaterMove</span></span><br><span class="line"><span class="title">pickWaterMove</span> <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line"><span class="title">pickWaterMove</span> _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="title">pickGrassMove</span> :: <span class="type">Grass</span> -&gt; <span class="type">GrassMove</span></span><br><span class="line"><span class="title">pickGrassMove</span> _ = <span class="type">VineWhip</span></span><br></pre></td></tr></table></figure><p>到目前为止还不错，类型检查器将确保我们只能创建正确的宝可梦，它们只能使用与它们的类型相匹配的超能力。</p><p>现在我们要让宝可梦们战斗了。战斗的视觉呈现会显示每个宝可梦使用的能力以及胜者，像这样：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">printBattle</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printBattle</span> pokemonOne moveOne pokemonTwo moveTwo winner = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ pokemonOne ++ <span class="string">" used "</span> ++ moveOne</span><br><span class="line">  putStrLn $ pokemonTwo ++ <span class="string">" used "</span> ++ moveTwo</span><br><span class="line">  putStrLn $ <span class="string">"Winner is: "</span> ++ winner ++ <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> =</span><br><span class="line">  printBattle <span class="string">"Water Pokemon"</span> <span class="string">"Water Attack"</span> <span class="string">"Fire Pokemon"</span> <span class="string">"Fire Attack"</span> <span class="string">"Water Pokemon"</span></span><br></pre></td></tr></table></figure><p>显示出使用的能力只是为了表达出战斗过程，我们会根据宝可梦的类型决定赢家，不管能力是什么。这里有一个水属性和火属性宝可梦之间战斗的例子。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">battleWaterVsFire</span> :: <span class="type">Water</span> -&gt; <span class="type">Fire</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">battleWaterVsFire</span> water fire = <span class="keyword">do</span></span><br><span class="line">  printBattle (show water) moveOne (show fire) moveTwo (show water)</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">  moveOne = show $ pickWaterMove water</span><br><span class="line">  moveTwo = show $ pickFireMove fire</span><br><span class="line"></span><br><span class="line"><span class="title">battleFireVsWater</span> = flip battleWaterVsFire <span class="comment">-- 和上面的一样，不过翻转了参数</span></span><br></pre></td></tr></table></figure><p>现在我们把这些代码放在在一起，定义剩下的战斗函数，就得到了一个程序！</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FireMove</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">WaterMove</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">GrassMove</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">pickFireMove</span> :: <span class="type">Fire</span> -&gt; <span class="type">FireMove</span></span><br><span class="line"><span class="title">pickFireMove</span> <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line"><span class="title">pickFireMove</span> <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line"><span class="title">pickFireMove</span> <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="title">pickWaterMove</span> :: <span class="type">Water</span> -&gt; <span class="type">WaterMove</span></span><br><span class="line"><span class="title">pickWaterMove</span> <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line"><span class="title">pickWaterMove</span> _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="title">pickGrassMove</span> :: <span class="type">Grass</span> -&gt; <span class="type">GrassMove</span></span><br><span class="line"><span class="title">pickGrassMove</span> _ = <span class="type">VineWhip</span></span><br><span class="line"></span><br><span class="line"><span class="title">printBattle</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printBattle</span> pokemonOne moveOne pokemonTwo moveTwo winner = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ pokemonOne ++ <span class="string">" used "</span> ++ moveOne</span><br><span class="line">  putStrLn $ pokemonTwo ++ <span class="string">" used "</span> ++ moveTwo</span><br><span class="line">  putStrLn $ <span class="string">"Winner is: "</span> ++ winner ++ <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示战斗的函数</span></span><br><span class="line"><span class="title">battleWaterVsFire</span> :: <span class="type">Water</span> -&gt; <span class="type">Fire</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">battleWaterVsFire</span> water fire = <span class="keyword">do</span></span><br><span class="line">  printBattle (show water) moveOne (show fire) moveTwo (show water)</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">  moveOne = show $ pickWaterMove water</span><br><span class="line">  moveTwo = show $ pickFireMove fire</span><br><span class="line"></span><br><span class="line"><span class="title">battleFireVsWater</span> = flip battleWaterVsFire</span><br><span class="line"></span><br><span class="line"><span class="title">battleGrassVsWater</span> :: <span class="type">Grass</span> -&gt; <span class="type">Water</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">battleGrassVsWater</span> grass water = <span class="keyword">do</span></span><br><span class="line">  printBattle (show grass) moveOne (show water) moveTwo (show grass)</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">  moveOne = show $ pickGrassMove grass</span><br><span class="line">  moveTwo = show $ pickWaterMove water</span><br><span class="line"></span><br><span class="line"><span class="title">battleWaterVsGrass</span> = flip battleGrassVsWater</span><br><span class="line"></span><br><span class="line"><span class="title">battleFireVsGrass</span> :: <span class="type">Fire</span> -&gt; <span class="type">Grass</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">battleFireVsGrass</span> fire grass = <span class="keyword">do</span></span><br><span class="line">  printBattle (show fire) moveOne (show grass) moveTwo (show fire)</span><br><span class="line"> <span class="keyword">where</span></span><br><span class="line">  moveOne = show $ pickFireMove fire</span><br><span class="line">  moveTwo = show $ pickGrassMove grass</span><br><span class="line"></span><br><span class="line"><span class="title">battleGrassVsFire</span> = flip battleFireVsGrass</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  battleWaterVsFire <span class="type">Squirtle</span> <span class="type">Charmander</span></span><br><span class="line">  battleFireVsWater <span class="type">Charmeleon</span> <span class="type">Wartortle</span></span><br><span class="line">  battleGrassVsWater <span class="type">Bulbasaur</span> <span class="type">Blastoise</span> </span><br><span class="line">  battleWaterVsGrass <span class="type">Wartortle</span> <span class="type">Ivysaur</span></span><br><span class="line">  battleFireVsGrass <span class="type">Charmeleon</span> <span class="type">Ivysaur</span></span><br><span class="line">  battleGrassVsFire <span class="type">Venusaur</span> <span class="type">Charizard</span></span><br></pre></td></tr></table></figure><h2 id="引入类型类"><a href="#引入类型类" class="headerlink" title="引入类型类"></a>引入类型类</h2><p>等等，这是在复读：试想一下有人在这些代码中加入一个电属性的皮卡丘，他们还得自己定义自己的 <code>battleElectricVs(Grass|Fire|Water)</code>函数。这里出现了一些模式，我们可以将其形式化，以帮助人们更好地理解宝可梦是什么，并帮助他们创造新的宝可梦。</p><p>这是我们学会的：</p><ul><li>宝可梦使用函数去选择它们的能力</li><li>战斗决定赢家并打印出战斗过程</li></ul><p>我们将定义一些类型类来使它们形式化，在过程中，我们还将讨论很妙的命名方案，其中每个函数都包含它所操作的类型。</p><p>在此，我假设你熟悉传统的类型类，如果不熟悉，请阅读 <a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" target="_blank" rel="noopener">Haskell 趣学指南的这章</a>。</p><h3 id="宝可梦类型类"><a href="#宝可梦类型类" class="headerlink" title="宝可梦类型类"></a>宝可梦类型类</h3><p>宝可梦类型将代表宝可梦选择它们能力的依据。它让我们定义的 <code>pickMove</code> 可被重载，以便同样的函数可以操作对于我们已经定义好的类型类的不同属性。</p><p>与原生的类型类不同，我们的宝可梦类型类需要知道两个类型：宝可梦的类型和能力类型，因为后者取决于前者。我们需要启用 MultiParamTypeClasses 语言扩展来让我们的类型类能接收两个参数。</p><p>还要注意，我们必须添加约束条件，这样宝可梦类型和能力类型也是可以 <code>show</code> 的。</p><p>以下是定义，以及现有宝可梦类型的一些实例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FireMove</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">WaterMove</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">GrassMove</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">pokemon</span>, <span class="type">Show</span> <span class="title">move</span>) =&gt; <span class="type">Pokemon</span> pokemon move <span class="keyword">where</span></span></span><br><span class="line">  pickMove :: pokemon -&gt; move</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Fire</span> <span class="type">FireMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line">  pickMove <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line">  pickMove <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line">  pickMove _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Grass</span> <span class="type">GrassMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove _ = <span class="type">VineWhip</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print (pickMove <span class="type">Charmander</span> :: <span class="type">FireMove</span>)</span><br><span class="line">  print (pickMove <span class="type">Blastoise</span> :: <span class="type">WaterMove</span>)</span><br><span class="line">  print (pickMove <span class="type">Bulbasaur</span> :: <span class="type">GrassMove</span>)</span><br></pre></td></tr></table></figure><p>注意事情是如何开始变得棘手的：由于宝可梦的类型和能力类型在类型类中作为分开的参数进行处理，调用 <code>pickMove</code> 和传入一个小火龙（Charmander）会让类型检查器查找看起来像 <code>Pokemon Fire a</code> 这样宝可梦类型类的实例，但我们没有，<strong>所以会失败</strong>。</p><p>可以试试在没有类型签名的情况下调用上面的 <code>pickMove</code>，然后看一下出现的错误。</p><p>通过表示我们希望 <code>pickMove</code> 产生一个 <code>FireMove</code>，我们给了类型检查器决定使用 <code>Pokemon Fire FireMove</code> 实例所需的所有信息。</p><h3 id="战斗类型类"><a href="#战斗类型类" class="headerlink" title="战斗类型类"></a>战斗类型类</h3><p>我们已经有了能够选择自己能力的宝可梦，现在我们需要一个表示宝可梦间能够相互战斗的抽象，来代替 <code>battle...Vs...</code> 这一系列函数。</p><p>所以接下来我们将定义另一个多参类型类（MultiParamTypeClass），限制参数为宝可梦多参类型类。我们还将定义每种希望支持战斗的类型类实例。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FireMove</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">WaterMove</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">GrassMove</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">pokemon</span>, <span class="type">Show</span> <span class="title">move</span>) =&gt; <span class="type">Pokemon</span> pokemon move <span class="keyword">where</span></span></span><br><span class="line">  pickMove :: pokemon -&gt; move</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Fire</span> <span class="type">FireMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line">  pickMove <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line">  pickMove <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line">  pickMove _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Grass</span> <span class="type">GrassMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove _ = <span class="type">VineWhip</span></span><br><span class="line">  </span><br><span class="line"><span class="title">printBattle</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printBattle</span> pokemonOne moveOne pokemonTwo moveTwo winner = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ pokemonOne ++ <span class="string">" used "</span> ++ moveOne</span><br><span class="line">  putStrLn $ pokemonTwo ++ <span class="string">" used "</span> ++ moveTwo</span><br><span class="line">  putStrLn $ <span class="string">"Winner is: "</span> ++ winner ++ <span class="string">"\n"</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 显示战斗类型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Pokemon</span> <span class="title">pokemon</span> <span class="title">move</span>, <span class="type">Pokemon</span> <span class="title">foe</span> <span class="title">foeMove</span>) =&gt; <span class="type">Battle</span> pokemon move foe foeMove <span class="keyword">where</span></span></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> ()</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show pokemon)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    move = pickMove pokemon</span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="type">Fire</span> <span class="type">FireMove</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">main :: <span class="type">IO</span> ()</span></span><br><span class="line"><span class="class">main = do</span></span><br><span class="line"><span class="class">  battle <span class="type">Squirtle</span> <span class="type">Charmander</span></span></span><br></pre></td></tr></table></figure><p>当我们运行上面的代码片段时会得到一个错误。类型检查器告诉我们：想要让杰尼龟（Squirtle）和小火龙（Charmander）战斗，我们得有一个像 <code>Battle Water move0 Fire foeMove0</code> 这样的类型类实例。</p><p>这又让我们回到了刚刚定义宝可梦多参类型类时的问题。在刚才那种情况下，我们通过在调用 <code>pickMove</code> 时加上类型签名解决了它。</p><p>因为战斗返回的类型是 <code>IO()</code>，这次我们就没那么走运了。</p><p>有一个快速并且糟糕的方法解决这个问题——让战斗返回使用的能力，这样我们就能在调用 <code>battle</code> 时加上类型签名来帮助类型检查器确定使用的类型类实例。所以，我们现在就这样做 :)</p><p>我会继续，并定义 <code>battle</code> 为返回 <code>IO(move, foeMove)</code>。接下来定义剩下的实例，完成与第一版相同的功能，只是现在一切都应该更加形式化一些。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE MultiParamTypeClasses #-&#125;</span></span><br><span class="line"><span class="keyword">import</span> Data.Tuple (<span class="title">swap</span>)</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">FireMove</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">WaterMove</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">GrassMove</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">pokemon</span>, <span class="type">Show</span> <span class="title">move</span>) =&gt; <span class="type">Pokemon</span> pokemon move <span class="keyword">where</span></span></span><br><span class="line">  pickMove :: pokemon -&gt; move</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Fire</span> <span class="type">FireMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line">  pickMove <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line">  pickMove <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line">  pickMove _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Grass</span> <span class="type">GrassMove</span> <span class="keyword">where</span></span></span><br><span class="line">  pickMove _ = <span class="type">VineWhip</span></span><br><span class="line"></span><br><span class="line"><span class="title">printBattle</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printBattle</span> pokemonOne moveOne pokemonTwo moveTwo winner = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ pokemonOne ++ <span class="string">" used "</span> ++ moveOne</span><br><span class="line">  putStrLn $ pokemonTwo ++ <span class="string">" used "</span> ++ moveTwo</span><br><span class="line">  putStrLn $ <span class="string">"Winner is: "</span> ++ winner ++ <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示我们的战斗类型类，恶星</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Pokemon</span> <span class="title">pokemon</span> <span class="title">move</span>, <span class="type">Pokemon</span> <span class="title">foe</span> <span class="title">foeMove</span>)</span></span><br><span class="line"><span class="class">  =&gt; <span class="type">Battle</span> pokemon move foe foeMove <span class="keyword">where</span></span></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> (move, foeMove)</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show pokemon)</span><br><span class="line">    return (move, foeMove)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line">    move = pickMove pokemon</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="type">Fire</span> <span class="type">FireMove</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">FireMove</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="keyword">where</span></span></span><br><span class="line">  battle a b = fmap swap $ flip battle a b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Grass</span> <span class="type">GrassMove</span> <span class="type">Water</span> <span class="type">WaterMove</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">WaterMove</span> <span class="type">Grass</span> <span class="type">GrassMove</span> <span class="keyword">where</span></span></span><br><span class="line">  battle a b = fmap swap $ flip battle a b</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">FireMove</span> <span class="type">Grass</span> <span class="type">GrassMove</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Grass</span> <span class="type">GrassMove</span> <span class="type">Fire</span> <span class="type">FireMove</span> <span class="keyword">where</span></span></span><br><span class="line">  battle a b = fmap swap $ flip battle a b</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  battle <span class="type">Squirtle</span> <span class="type">Charmander</span> :: <span class="type">IO</span> (<span class="type">WaterMove</span>, <span class="type">FireMove</span>)</span><br><span class="line">  battle <span class="type">Charmeleon</span> <span class="type">Wartortle</span> :: <span class="type">IO</span> (<span class="type">FireMove</span>, <span class="type">WaterMove</span>)</span><br><span class="line">  battle <span class="type">Bulbasaur</span> <span class="type">Blastoise</span> :: <span class="type">IO</span> (<span class="type">GrassMove</span>, <span class="type">WaterMove</span>)</span><br><span class="line">  battle <span class="type">Wartortle</span> <span class="type">Ivysaur</span> :: <span class="type">IO</span> (<span class="type">WaterMove</span>, <span class="type">GrassMove</span>)</span><br><span class="line">  battle <span class="type">Charmeleon</span> <span class="type">Ivysaur</span> :: <span class="type">IO</span> (<span class="type">FireMove</span>, <span class="type">GrassMove</span>)</span><br><span class="line">  battle <span class="type">Venusaur</span> <span class="type">Charizard</span> :: <span class="type">IO</span> (<span class="type">GrassMove</span>, <span class="type">FireMove</span>)</span><br><span class="line">  putStrLn <span class="string">"Done Fighting"</span></span><br></pre></td></tr></table></figure><h2 id="最后，引入类型家族！"><a href="#最后，引入类型家族！" class="headerlink" title="最后，引入类型家族！"></a>最后，引入类型家族！</h2><p>所以，到目前为止，我们的程序有点糟糕。我们必须携带所有这些类型签名，甚至不得不改变一个函数（战斗）内部行为以便我们能够使用类型签名去帮助编译器。我可以说，当前这版程序尽管更加形式、更少重复，在引入所有新的恶星代码之后并没有太大改进。</p><p>但我们可以追回到宝可梦类型类定义时的恶星之处。它拥有宝可梦的类型以及动作类型作为两个独立的类变量：类型检查器不知道在宝可梦类型和动作类型间它可利用的关系。它甚至可以允许我们定义水属性的宝可梦执行火属性动作！这并不对，但你可以这么做。回去尝试创建一个 <code>Pokemon Fire WaterMove</code> 实例。</p><p>这就是类型家族发挥作用的地：它们让我们告诉类型检查器火属性的宝可梦需要和火属性动作在一起，等。</p><h3 id="使用类型家族的宝可梦类型类"><a href="#使用类型家族的宝可梦类型类" class="headerlink" title="使用类型家族的宝可梦类型类"></a>使用类型家族的宝可梦类型类</h3><p>为了使用类型家族，我们需要开启 TypeFamilies 扩展。这样做之后，我们的宝可梦类型类看起来如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">a</span>, <span class="type">Show</span> (<span class="type">Move</span> <span class="title">a</span>)) =&gt; <span class="type">Pokemon</span> a <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> a :: *</span></span><br><span class="line">  pickMove :: a -&gt; <span class="type">Move</span> a</span><br></pre></td></tr></table></figure><p>我们定义宝可梦类型类拥有一个参数和一个关联的 Move 类型。Move 成为了一个“类型函数”，返回要用到动作的类型。这意味着我们将有 <code>Move Fire</code> 而不是 <code>FireMove</code>、<code>Move Water</code> 而不是 <code>WaterMove</code>，等等。</p><p>注意，类型约束看起来和前一个相似，只是我们使用 <code>Show (Move a))</code> 来代替 <code>Show move</code>。我们需要开启另一个扩展来实现：FlexibleContexts.</p><p>之后，Haskell 提供了很妙的语法糖，这样我们就可以在定义实例时定义实际关联数据类型的构造函数。</p><p>让我们重新定义所有的这些数据类型、我们的宝可梦类型类，以及所有需要使用类型家族的实例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies, FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">pokemon</span>, <span class="type">Show</span> (<span class="type">Move</span> <span class="title">pokemon</span>)) =&gt; <span class="type">Pokemon</span> pokemon <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> pokemon :: *</span></span><br><span class="line">  pickMove :: pokemon -&gt; <span class="type">Move</span> pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Fire</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line">  pickMove <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line">  pickMove <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Water</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Water</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line">  pickMove _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Grass</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Grass</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove _ = <span class="type">VineWhip</span></span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  print $ pickMove <span class="type">Squirtle</span></span><br><span class="line">  print $ pickMove <span class="type">Charmander</span></span><br><span class="line">  print $ pickMove <span class="type">Ivysaur</span></span><br></pre></td></tr></table></figure><p>炒鸡整洁，对吧？我们不需要为 <code>pickMove</code> 添加类型签名了！先不要着急向上滚动：等待第三版程序完善之后，再与第二版比较以获得完整的效果。</p><h3 id="船新的战斗类型类"><a href="#船新的战斗类型类" class="headerlink" title="船新的战斗类型类"></a>船新的战斗类型类</h3><p>因此，现在我们不需要那些冗长的类型签名，可以回到引入恶星黑科技前，回到 <code>battle</code> 的上一个版本，它只返回 <code>IO ()</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Pokemon</span> <span class="title">pokemon</span>, <span class="type">Pokemon</span> <span class="title">foe</span>) =&gt; <span class="type">Battle</span> pokemon foe <span class="keyword">where</span></span></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> ()</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show pokemon)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line">    move = pickMove pokemon</span><br></pre></td></tr></table></figure><p>此外，注意战斗不再需要知道动作了，它又回到了在我们第一版中的萌新实现那样。</p><p>让我再一次定义所有剩余的战斗实例，并给你第三次版的完整程序：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">pokemon</span>, <span class="type">Show</span> (<span class="type">Move</span> <span class="title">pokemon</span>)) =&gt; <span class="type">Pokemon</span> pokemon <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> pokemon :: *</span></span><br><span class="line">  pickMove :: pokemon -&gt; <span class="type">Move</span> pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Fire</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line">  pickMove <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line">  pickMove <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Water</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Water</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line">  pickMove _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Grass</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Grass</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove _ = <span class="type">VineWhip</span></span><br><span class="line"></span><br><span class="line"><span class="title">printBattle</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printBattle</span> pokemonOne moveOne pokemonTwo moveTwo winner = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ pokemonOne ++ <span class="string">" used "</span> ++ moveOne</span><br><span class="line">  putStrLn $ pokemonTwo ++ <span class="string">" used "</span> ++ moveTwo</span><br><span class="line">  putStrLn $ <span class="string">"Winner is: "</span> ++ winner ++ <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Pokemon</span> <span class="title">pokemon</span>, <span class="type">Pokemon</span> <span class="title">foe</span>) =&gt; <span class="type">Battle</span> pokemon foe <span class="keyword">where</span></span></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> ()</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show pokemon)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line">    move = pickMove pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">Fire</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">Water</span> <span class="keyword">where</span></span></span><br><span class="line">  battle = flip battle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Grass</span> <span class="type">Water</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">Grass</span> <span class="keyword">where</span></span></span><br><span class="line">  battle = flip battle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">Grass</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Grass</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  battle = flip battle</span><br><span class="line">    </span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  battle <span class="type">Squirtle</span> <span class="type">Charmander</span></span><br><span class="line">  battle <span class="type">Charmeleon</span> <span class="type">Wartortle</span></span><br><span class="line">  battle <span class="type">Bulbasaur</span> <span class="type">Blastoise</span></span><br><span class="line">  battle <span class="type">Wartortle</span> <span class="type">Ivysaur</span></span><br><span class="line">  battle <span class="type">Charmeleon</span> <span class="type">Ivysaur</span></span><br><span class="line">  battle <span class="type">Venusaur</span> <span class="type">Charizard</span></span><br></pre></td></tr></table></figure><p>就这样。我们的程序最终看起来很不错，我们已经改进到现在的程度，引入更多的类型检查，更少的重复，并且有一个整洁的 API 提供给其他开发人员。</p><p>酷！我们完成了！希望你喜欢！</p><p>好吧，我明白了，你现在很开心，你不能相信这么快就结束了，而且你已经看了你的浏览器的滚动条，它仍然显示下面还有更多的页面可以看。</p><p>所以，让我们给宝可梦世界添加一个新特性：</p><p>现在我们将水属性和火属性的战斗实力定义为 <code>Battle Water Fire</code>，之后我们定义 <code>Battle Water Fire</code> 是同样一个战斗，只是与前一个相比参数翻转了。第一个传给 <code>battle</code> 的宝可梦一定是赢者，输出总是如下的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Winner Pokemon move</span></span><br><span class="line"><span class="comment">-- Loser Pokemon move</span></span><br><span class="line"><span class="comment">-- Winner pokemon Wins.</span></span><br></pre></td></tr></table></figure><p>尽管在实例中输者是第一个参数，第一行的输出总是赢者的攻击。</p><p>但让我们改变这一点，让战斗实例能够决定谁是这场比赛的赢者，以便在某些情况下战斗的最终结果是：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Loser Pokemon move</span></span><br><span class="line"><span class="comment">-- Winner Pokemon move</span></span><br><span class="line"><span class="comment">-- Winner pokemon Wins</span></span><br></pre></td></tr></table></figure><h3 id="关联类型别名"><a href="#关联类型别名" class="headerlink" title="关联类型别名"></a>关联类型别名</h3><p>当决定返回两种值的任意一种时，你通常会返回一个<code>Either a b</code>，但这是在运行期。我们希望类型检查器能够保证水与火的战斗中水总是赢者。</p><p>所以我们在 <code>Battle</code> 中定义了新的函数 <code>winner</code>，以同样顺序接收传给 <code>battle</code> 函数的两个竞争对手，并决定谁是赢者。</p><p>不管返回哪个输入的宝可梦，都会让 <code>winner</code> 函数变复杂，你可以自己看一下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Pokemon</span> <span class="title">pokemon</span>, <span class="type">Pokemon</span> <span class="title">foe</span>) =&gt; <span class="type">Battle</span> pokemon foe <span class="keyword">where</span></span></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> ()</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show pokemon)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line">    move = pickMove pokemon</span><br><span class="line">  </span><br><span class="line">  winner :: pokemon -&gt; foe -&gt; ??? <span class="comment">-- 是 `pokemon` 还是 `foe`？</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  winner :: <span class="type">Water</span> -&gt; <span class="type">Fire</span> -&gt; <span class="type">Water</span> <span class="comment">-- 水是类型类的第一个类型变量，应该是 `pokemon`</span></span><br><span class="line">  winner water _ = water</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">Water</span></span></span><br><span class="line"><span class="class">  winner :: <span class="type">Fire</span> -&gt; <span class="type">Water</span> -&gt; <span class="type">Water</span> <span class="comment">-- 水是类型类的第二个类型变量，应该是 `foe`</span></span></span><br><span class="line"><span class="class">  winner _ water = water</span></span><br></pre></td></tr></table></figure><p>看，对于 <code>Battle Water Fire</code> 实例，<code>winner</code> 的返回类型会和类型类中的 <code>pokemon</code> 类型变量相同，而对于 <code>Battle Fire Water</code> 返回类型则是 <code>foe</code>。</p><p>幸运的是，类型家族还包括关联类型同义词的支持：在战斗类型类中我们定义一个 <code>Winner pokemon foo</code> 关联类型，让实例去决定使用的类型。</p><p>我们使用了关键字 <code>type</code> 而不是 <code>data</code>，因为它将是 <code>pokemon</code> 或者 <code>foe</code> 的类型别名。</p><p><code>Winner</code> 本身是一个 kind 为 <code>* -&gt; * -&gt; *</code> 的类型函数，同时接收 <code>pokemon</code> 和 <code>foo</code>，并返回将使用的那个。</p><p>我们还定义了 <code>Winner</code> 的默认实现，给定 <code>pokemon</code> 和 <code>foo</code> 时它会选择 <code>pokemon</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> (<span class="type">Winner</span> <span class="title">pokemon</span> <span class="title">foe</span>), <span class="type">Pokemon</span> pokemon, <span class="type">Pokemon</span> foe) =&gt; <span class="type">Battle</span> pokemon foe <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> pokemon foe :: * <span class="comment">-- 这是个关联类型</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> pokemon foe = pokemon <span class="comment">-- 这是它的默认实现</span></span></span><br><span class="line"></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> ()</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show winner)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line">    move = pickMove pokemon</span><br><span class="line">    winner = pickWinner pokemon foe</span><br><span class="line">  </span><br><span class="line">  pickWinner :: pokemon -&gt; foe -&gt; (<span class="type">Winner</span> pokemon foe)</span><br></pre></td></tr></table></figure><p>这就是宝可梦的最终程序了，有时敌人会赢得战斗：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleContexts #-&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> <span class="title">pokemon</span>, <span class="type">Show</span> (<span class="type">Move</span> <span class="title">pokemon</span>)) =&gt; <span class="type">Pokemon</span> pokemon <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> pokemon :: *</span></span><br><span class="line">  pickMove :: pokemon -&gt; <span class="type">Move</span> pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Fire</span> = <span class="type">Charmander</span> | <span class="type">Charmeleon</span> | <span class="type">Charizard</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Fire</span> = <span class="type">Ember</span> | <span class="type">FlameThrower</span> | <span class="type">FireBlast</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove <span class="type">Charmander</span> = <span class="type">Ember</span></span><br><span class="line">  pickMove <span class="type">Charmeleon</span> = <span class="type">FlameThrower</span></span><br><span class="line">  pickMove <span class="type">Charizard</span> = <span class="type">FireBlast</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Water</span> = <span class="type">Squirtle</span> | <span class="type">Wartortle</span> | <span class="type">Blastoise</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Water</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Water</span> = <span class="type">Bubble</span> | <span class="type">WaterGun</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove <span class="type">Squirtle</span> = <span class="type">Bubble</span></span><br><span class="line">  pickMove _ = <span class="type">WaterGun</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Grass</span> = <span class="type">Bulbasaur</span> | <span class="type">Ivysaur</span> | <span class="type">Venusaur</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Pokemon</span> <span class="type">Grass</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">data</span> <span class="type">Move</span> <span class="type">Grass</span> = <span class="type">VineWhip</span> <span class="keyword">deriving</span> <span class="type">Show</span></span></span><br><span class="line">  pickMove _ = <span class="type">VineWhip</span></span><br><span class="line"></span><br><span class="line"><span class="title">printBattle</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">printBattle</span> pokemonOne moveOne pokemonTwo moveTwo winner = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ pokemonOne ++ <span class="string">" used "</span> ++ moveOne</span><br><span class="line">  putStrLn $ pokemonTwo ++ <span class="string">" used "</span> ++ moveTwo</span><br><span class="line">  putStrLn $ <span class="string">"Winner is: "</span> ++ winner ++ <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Show</span> (<span class="type">Winner</span> <span class="title">pokemon</span> <span class="title">foe</span>), <span class="type">Pokemon</span> pokemon, <span class="type">Pokemon</span> foe) =&gt; <span class="type">Battle</span> pokemon foe <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> pokemon foe :: *</span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> pokemon foe = pokemon</span></span><br><span class="line"></span><br><span class="line">  battle :: pokemon -&gt; foe -&gt; <span class="type">IO</span> ()</span><br><span class="line">  battle pokemon foe = <span class="keyword">do</span></span><br><span class="line">    printBattle (show pokemon) (show move) (show foe) (show foeMove) (show winner)</span><br><span class="line">   <span class="keyword">where</span></span><br><span class="line">    foeMove = pickMove foe</span><br><span class="line">    move = pickMove pokemon</span><br><span class="line">    winner = pickWinner pokemon foe</span><br><span class="line">  </span><br><span class="line">  pickWinner :: pokemon -&gt; foe -&gt; (<span class="type">Winner</span> pokemon foe)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  pickWinner pokemon foe = pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">Water</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> <span class="type">Fire</span> <span class="type">Water</span> = <span class="type">Water</span></span></span><br><span class="line">  pickWinner = flip pickWinner</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Grass</span> <span class="type">Water</span> <span class="keyword">where</span></span></span><br><span class="line">  pickWinner pokemon foe = pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Water</span> <span class="type">Grass</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> <span class="type">Water</span> <span class="type">Grass</span> = <span class="type">Grass</span></span></span><br><span class="line">  pickWinner = flip pickWinner</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Fire</span> <span class="type">Grass</span> <span class="keyword">where</span></span></span><br><span class="line">  pickWinner pokemon foe = pokemon</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Battle</span> <span class="type">Grass</span> <span class="type">Fire</span> <span class="keyword">where</span></span></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="type">Winner</span> <span class="type">Grass</span> <span class="type">Fire</span> = <span class="type">Fire</span></span></span><br><span class="line">  pickWinner = flip pickWinner</span><br><span class="line">    </span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  battle <span class="type">Squirtle</span> <span class="type">Charmander</span></span><br><span class="line">  battle <span class="type">Charmeleon</span> <span class="type">Wartortle</span></span><br><span class="line">  battle <span class="type">Bulbasaur</span> <span class="type">Blastoise</span></span><br><span class="line">  battle <span class="type">Wartortle</span> <span class="type">Ivysaur</span></span><br><span class="line">  battle <span class="type">Charmeleon</span> <span class="type">Ivysaur</span></span><br><span class="line">  battle <span class="type">Venusaur</span> <span class="type">Charizard</span></span><br></pre></td></tr></table></figure><p>就这样！尝试在上面的代码片段末尾加上你的电属性宝可梦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文：&lt;br&gt;&lt;a href=&quot;https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nubis, 16 Mar 2013, School of Haskell&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在我开始学 haskell 时有些不知所措。最初我把它用于一个实际的工作项目，然后我发现几乎所有的库都使用了仅在 GHC 可用的语言扩展。这让我开始有点失望，毕竟，谁想使用一种如此贫瘠的语言，以至于你需要依靠一个编译器的扩展才能实际去应用它，对吧？&lt;/p&gt;
&lt;p&gt;好吧，我振作起来，决定学习所有这些扩展。我发现 Haskell 社区有三个热门话题，它们都在说有关 GADT、类型家族和依赖函数类似的问题。于是我试着查找资料去了解它们，但我只能找到描述它们是什么、如何使用的文章，没有一篇真正地解释为什么我们是怎么需要它们的！因此，我决定用一个友好的例子来写这篇教程，解释我们为什么需要类型家族。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://berberman.cn/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft-Bukkit插件-插件类加载器</title>
    <link href="https://berberman.cn/2018/05/08/minecraft-plugin-classloader/"/>
    <id>https://berberman.cn/2018/05/08/minecraft-plugin-classloader/</id>
    <published>2018-05-08T00:02:03.000Z</published>
    <updated>2020-08-13T10:39:10.633Z</updated>
    
    <content type="html"><![CDATA[<p>在开发 Bukkit 插件库的过程中，有时会需要用到插件主类实例的情况。举一个栗子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registerEventListeners(<span class="keyword">this</span>) &#123;</span><br><span class="line">event&lt;PlayerJoinEvent&gt; &#123;</span><br><span class="line">player.sendMessage(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为事件监听器的注册需要绑定在插件上，对于库/前置插件开发者来说，需要每次用到插件实例时让调用者提供。看起来没什么不对的，但这里有一个更好的方法。我们先来分析下插件是如何加载的。</p><h2 id="插件注册分析"><a href="#插件注册分析" class="headerlink" title="插件注册分析"></a>插件注册分析</h2><p>服务器插件的加载是由 <code>CraftServer</code> 的 <code>loadPlugins</code> 开始的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CraftServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPlugins</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pluginManager.registerInterface(JavaPluginLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        File pluginFolder = (File)<span class="keyword">this</span>.console.options.valueOf(<span class="string">"plugins"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pluginFolder.exists()) &#123;</span><br><span class="line">            Plugin[] plugins = <span class="keyword">this</span>.pluginManager.loadPlugins(pluginFolder);</span><br><span class="line">            Plugin[] var6 = plugins;</span><br><span class="line">            <span class="keyword">int</span> var5 = plugins.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var5; ++var4) &#123;</span><br><span class="line">                Plugin plugin = var6[var4];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String message = String.format(<span class="string">"Loading %s"</span>, plugin.getDescription().getFullName());</span><br><span class="line">                    plugin.getLogger().info(message);</span><br><span class="line">                    plugin.onLoad();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var8) &#123;</span><br><span class="line">                    Logger.getLogger(CraftServer.class.getName()).log(Level.SEVERE, var8.getMessage() + " initializing " + plugin.getDescription().getFullName() + " (Is it up to date?)", var8);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pluginFolder.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>CraftServer</code> 调用了其内部持有的 <code>SimplePluginManager</code> 的 <code>registerInterface(JavaPluginLoader.class)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePluginManager</span> <span class="keyword">implements</span> <span class="title">PluginManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInterface</span><span class="params">(Class&lt;? extends PluginLoader&gt; loader)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        PluginLoader instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PluginLoader<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">loader</span>)) </span>&#123;</span><br><span class="line">            Constructor&lt;? extends PluginLoader&gt; constructor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                constructor = loader.getConstructor(Server<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                instance = constructor.newInstance(server);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                String className = loader.getName();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Class %s does not have a public %s(Server) constructor"</span>, className, className), ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Unexpected exception %s while attempting to construct a new instance of %s"</span>, ex.getClass().getName(), loader.getName()), ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Class %s does not implement interface PluginLoader"</span>, loader.getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pattern[] patterns = instance.getPluginFileFilters();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pattern pattern : patterns) &#123;</span><br><span class="line">                fileAssociations.put(pattern, instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步<code>SimplePluginManager</code> 负责 new 出 <code>JavaPluginLoader</code> 的实例，并且将插件名字过滤正则与 <code>JavaPluginLoader</code> 实例对应。（默认情况下 <code>PluginLoader</code> 接口仅有一个实现类 <code>JavaPluginLoader</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaPluginLoader</span> <span class="keyword">implements</span> <span class="title">PluginLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Pattern[] fileFilters = [Pattern.compile(<span class="string">"\\.jar$"</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>JavaPluginLoader</code> 只含有一个正则表达式，用于过滤插件文件夹中的文件。<br>接着，<code>CraftServer</code> 会调用 <code>SimplePluginManager</code> 的 <code>loadPlugins(File)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Plugin[] loadPlugins(File directory) &#123;</span><br><span class="line">    Validate.notNull(directory, <span class="string">"Directory cannot be null"</span>);</span><br><span class="line">    Validate.isTrue(directory.isDirectory(), <span class="string">"Directory must be a directory"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Plugin&gt; result = <span class="keyword">new</span> ArrayList&lt;Plugin&gt;();</span><br><span class="line">    Set&lt;Pattern&gt; filters = fileAssociations.keySet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(server.getUpdateFolder().equals(<span class="string">""</span>))) &#123;</span><br><span class="line">        updateDirectory = <span class="keyword">new</span> File(directory, server.getUpdateFolder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, File&gt; plugins = <span class="keyword">new</span> HashMap&lt;String, File&gt;();</span><br><span class="line">    Set&lt;String&gt; loadedPlugins = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    Map&lt;String, Collection&lt;String&gt;&gt; dependencies = <span class="keyword">new</span> HashMap&lt;String, Collection&lt;String&gt;&gt;();</span><br><span class="line">    Map&lt;String, Collection&lt;String&gt;&gt; softDependencies = <span class="keyword">new</span> HashMap&lt;String, Collection&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is where it figures out all possible plugins</span></span><br><span class="line">    <span class="keyword">for</span> (File file : directory.listFiles()) &#123;</span><br><span class="line">        PluginLoader loader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Pattern filter : filters) &#123;</span><br><span class="line">            Matcher match = filter.matcher(file.getName());</span><br><span class="line">            <span class="keyword">if</span> (match.find()) &#123;</span><br><span class="line">                loader = fileAssociations.get(filter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        PluginDescriptionFile description = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            description = loader.getPluginDescription(file);</span><br><span class="line">            String name = description.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">"bukkit"</span>) || name.equalsIgnoreCase(<span class="string">"minecraft"</span>) || name.equalsIgnoreCase(<span class="string">"mojang"</span>)) &#123;</span><br><span class="line">                server.getLogger().log(Level.SEVERE, <span class="string">"Could not load '"</span> + file.getPath() + <span class="string">"' in folder '"</span> + directory.getPath() + <span class="string">"': Restricted Name"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (description.rawName.indexOf(<span class="string">' '</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                server.getLogger().log(Level.SEVERE, <span class="string">"Could not load '"</span> + file.getPath() + <span class="string">"' in folder '"</span> + directory.getPath() + <span class="string">"': uses the space-character (0x20) in its name"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidDescriptionException ex) &#123;</span><br><span class="line">            server.getLogger().log(Level.SEVERE, <span class="string">"Could not load '"</span> + file.getPath() + <span class="string">"' in folder '"</span> + directory.getPath() + <span class="string">"'"</span>, ex);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File replacedFile = plugins.put(description.getName(), file);</span><br><span class="line">        <span class="keyword">if</span> (replacedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.getLogger().severe(String.format(</span><br><span class="line">                <span class="string">"Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'"</span>,</span><br><span class="line">                description.getName(),</span><br><span class="line">                file.getPath(),</span><br><span class="line">                replacedFile.getPath(),</span><br><span class="line">                directory.getPath()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//省去通过依赖分析来决定加载顺序。</span></span><br><span class="line">    <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Plugin[result.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会找到目录下所有 jar 文件，并调用 <code>JavaPluginLoader</code> 的 <code>getPluginDescription(File)</code> 方法，找到目录下所有插件的描述文件。下一步会根据 <code>softDependency</code> 和 <code>dependency</code> 处理各个插件的加载顺序，并进行一系列的合法性校验，并对每个合法文件调用 <code>loadPlugin(File)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePluginManager</span> <span class="keyword">implements</span> <span class="title">PluginManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Plugin <span class="title">loadPlugin</span><span class="params">(File file)</span> <span class="keyword">throws</span> InvalidPluginException, UnknownDependencyException </span>&#123;</span><br><span class="line">        Validate.notNull(file, <span class="string">"File cannot be null"</span>);</span><br><span class="line"></span><br><span class="line">        checkUpdate(file);</span><br><span class="line"></span><br><span class="line">        Set&lt;Pattern&gt; filters = fileAssociations.keySet();</span><br><span class="line">        Plugin result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Pattern filter : filters) &#123;</span><br><span class="line">        String name = file.getName();</span><br><span class="line">        Matcher match = filter.matcher(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (match.find()) &#123;</span><br><span class="line">            PluginLoader loader = fileAssociations.get(filter);</span><br><span class="line"></span><br><span class="line">            result = loader.loadPlugin(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        plugins.add(result);</span><br><span class="line">        lookupNames.put(result.getDescription().getName(), result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当正则匹配时，方法调用了 <code>fileAssociations</code> 中存的 loader，也就是 <code>JavaPluginLoader</code> 的 <code>loadPlugin(File)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaPluginLoader</span> <span class="keyword">implements</span> <span class="title">PluginLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plugin <span class="title">loadPlugin</span><span class="params">(<span class="keyword">final</span> File file)</span> <span class="keyword">throws</span> InvalidPluginException </span>&#123;</span><br><span class="line">        Validate.notNull(file, <span class="string">"File cannot be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(<span class="keyword">new</span> FileNotFoundException(file.getPath() + <span class="string">" does not exist"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PluginDescriptionFile description;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            description = getPluginDescription(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidDescriptionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> File parentFile = file.getParentFile();</span><br><span class="line">        <span class="keyword">final</span> File dataFolder = <span class="keyword">new</span> File(parentFile, description.getName());</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        <span class="keyword">final</span> File oldDataFolder = <span class="keyword">new</span> File(parentFile, description.getRawName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Found old data folder</span></span><br><span class="line">        <span class="keyword">if</span> (dataFolder.equals(oldDataFolder)) &#123;</span><br><span class="line">            <span class="comment">// They are equal -- nothing needs to be done!</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataFolder.isDirectory() &amp;&amp; oldDataFolder.isDirectory()) &#123;</span><br><span class="line">            server.getLogger().warning(String.format(</span><br><span class="line">                <span class="string">"While loading %s (%s) found old-data folder: `%s' next to the new one `%s'"</span>,</span><br><span class="line">                description.getFullName(),</span><br><span class="line">                file,</span><br><span class="line">                oldDataFolder,</span><br><span class="line">                dataFolder</span><br><span class="line">            ));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldDataFolder.isDirectory() &amp;&amp; !dataFolder.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!oldDataFolder.renameTo(dataFolder)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(<span class="string">"Unable to rename old data folder: `"</span> + oldDataFolder + <span class="string">"' to: `"</span> + dataFolder + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            server.getLogger().log(Level.INFO, String.format(</span><br><span class="line">                <span class="string">"While loading %s (%s) renamed data folder: `%s' to `%s'"</span>,</span><br><span class="line">                description.getFullName(),</span><br><span class="line">                file,</span><br><span class="line">                oldDataFolder,</span><br><span class="line">                dataFolder</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataFolder.exists() &amp;&amp; !dataFolder.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(String.format(</span><br><span class="line">                <span class="string">"Projected datafolder: `%s' for %s (%s) exists and is not a directory"</span>,</span><br><span class="line">                dataFolder,</span><br><span class="line">                description.getFullName(),</span><br><span class="line">                file</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String pluginName : description.getDepend()) &#123;</span><br><span class="line">            Plugin current = server.getPluginManager().getPlugin(pluginName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnknownDependencyException(pluginName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PluginClassLoader loader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = <span class="keyword">new</span> PluginClassLoader(<span class="keyword">this</span>, getClass().getClassLoader(), description, dataFolder, file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidPluginException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        loaders.add(loader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loader.plugin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对插件数据文件夹进行诸如创建之类的操作，并且检测当前插件的依赖是否全部已经被加载。接下来最重要的一步为 new 出 <code>PluginClassLoader</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    PluginClassLoader(<span class="keyword">final</span> JavaPluginLoader loader, <span class="keyword">final</span> ClassLoader parent, <span class="keyword">final</span> PluginDescriptionFile description, <span class="keyword">final</span> File dataFolder, <span class="keyword">final</span> File file) <span class="keyword">throws</span> IOException, InvalidPluginException, MalformedURLException &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> URL[] &#123;file.toURI().toURL()&#125;, parent);</span><br><span class="line">        Validate.notNull(loader, <span class="string">"Loader cannot be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">        <span class="keyword">this</span>.dataFolder = dataFolder;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line">        <span class="keyword">this</span>.jar = <span class="keyword">new</span> JarFile(file);</span><br><span class="line">        <span class="keyword">this</span>.manifest = jar.getManifest();</span><br><span class="line">        <span class="keyword">this</span>.url = file.toURI().toURL();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; jarClass;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jarClass = Class.forName(description.getMain(), <span class="keyword">true</span>, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(<span class="string">"Cannot find main class `"</span> + description.getMain() + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;? extends JavaPlugin&gt; pluginClass;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pluginClass = jarClass.asSubclass(JavaPlugin<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(<span class="string">"main class `"</span> + description.getMain() + <span class="string">"' does not extend JavaPlugin"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            plugin = pluginClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(<span class="string">"No public constructor"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidPluginException(<span class="string">"Abnormal plugin type"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PluginClassLoader</code> 构造器中校验插件主类，并使用反射在本类加载器下创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaPlugin</span> <span class="keyword">extends</span> <span class="title">PluginBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClassLoader classLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (!(classLoader <span class="keyword">instanceof</span> PluginClassLoader)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"JavaPlugin requires "</span> + PluginClassLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ((PluginClassLoader) classLoader).initialize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>JavaPlugin</code> 的构造器中，其调用了 <code>PluginClassLoader</code> 的 <code>initialize(JavaPlugin)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(JavaPlugin javaPlugin)</span> </span>&#123;</span><br><span class="line">        Validate.notNull(javaPlugin, <span class="string">"Initializing plugin cannot be null"</span>);</span><br><span class="line">        Validate.isTrue(javaPlugin.getClass().getClassLoader() == <span class="keyword">this</span>, <span class="string">"Cannot initialize plugin outside of this class loader"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.plugin != <span class="keyword">null</span> || <span class="keyword">this</span>.pluginInit != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Plugin already initialized!"</span>, pluginState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pluginState = <span class="keyword">new</span> IllegalStateException(<span class="string">"Initial initialization"</span>);</span><br><span class="line">        <span class="keyword">this</span>.pluginInit = javaPlugin;</span><br><span class="line"></span><br><span class="line">        javaPlugin.init(loader, loader.server, description, dataFolder, file, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del><code>pluginState</code> 居然是 <code>IllegalArgumentException</code>，我觉得布星。</del><br>这里 <code>initialize(JavaPlugin)</code> 又调用了 <code>JavaPlugin</code> 的<code>init(PluginLoader, Server, PluginDescriptionFile, File, File, ClassLoader)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaPlugin</span> <span class="keyword">extends</span> <span class="title">PluginBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loader = loader;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">        <span class="keyword">this</span>.dataFolder = dataFolder;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">        <span class="keyword">this</span>.configFile = <span class="keyword">new</span> File(dataFolder, <span class="string">"config.yml"</span>);</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> PluginLogger(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法传入了一些参数，供插件编写者使用。至此，一个插件就加载好了。</p><h2 id="大雾"><a href="#大雾" class="headerlink" title="大雾"></a>大雾</h2><p>了解一个插件是如何被加载后，我们可以从属于该插件代码内的任何一个实例获取插件主类的实例。直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jaba</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JavaPlugin <span class="title">jaba</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoader = object.getClass().getClassLoader();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; loaderClass = Class.forName(<span class="string">"org.bukkit.plugin.java.PluginClassLoader"</span>);</span><br><span class="line"><span class="keyword">if</span>(!loaderClass.isInstance(classLoader))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalPluginAccessException();</span><br><span class="line">Field pluginField = loaderClass.getField(<span class="string">"plugin"</span>);</span><br><span class="line">pluginField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> (JavaPlugin) pluginField.get(classLoader);</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalPluginAccessException(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万恶的 <code>PluginClassLoader</code> 是 package-private 的，所以需要通过反射访问。只是这段代码是 100% 不可能用到的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发 Bukkit 插件库的过程中，有时会需要用到插件主类实例的情况。举一个栗子：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;registerEventListeners(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	event&amp;lt;PlayerJoinEvent&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		player.sendMessage(&lt;span class=&quot;string&quot;&gt;&quot;Hello!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为事件监听器的注册需要绑定在插件上，对于库/前置插件开发者来说，需要每次用到插件实例时让调用者提供。看起来没什么不对的，但这里有一个更好的方法。我们先来分析下插件是如何加载的。&lt;/p&gt;
&lt;h2 id=&quot;插件注册分析&quot;&gt;&lt;a href=&quot;#插件注册分析&quot; class=&quot;headerlink&quot; title=&quot;插件注册分析&quot;&gt;&lt;/a&gt;插件注册分析&lt;/h2&gt;&lt;p&gt;服务器插件的加载是由 &lt;code&gt;CraftServer&lt;/code&gt; 的 &lt;code&gt;loadPlugins&lt;/code&gt; 开始的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Minecraft" scheme="https://berberman.cn/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft-Bukkit插件-DSL注册事件监听器</title>
    <link href="https://berberman.cn/2018/01/31/minecraft-dsl-event/"/>
    <id>https://berberman.cn/2018/01/31/minecraft-dsl-event/</id>
    <published>2018-01-31T10:08:43.000Z</published>
    <updated>2020-08-13T10:39:10.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次介绍了如何在 Kotlin 语言中使用 DSL 构造注册命令，这篇来写一下注册事件监听器。</p><p>注册监听器通常情况下都是用 <code>@EventHandler</code> 标注一个方法，写在一个实现空接口 <code>Listener</code> 的类中，像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DemoListener : Listener &#123;</span><br><span class="line"><span class="meta">@EventHandler</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onPlayJoin</span><span class="params">(event: <span class="type">PlayerJoinEvent</span>)</span></span> &#123;</span><br><span class="line">event.player.sendMessage(ChatColor.AQUA + <span class="string">"Hi!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插件启动时写上：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pluginManager.registerEvents(DemoListener, plugin)</span><br></pre></td></tr></table></figure><p>就可以正常食用了。如果不通过注解反射实现呢？我们需要翻一下源码，看看他的底层是怎么实现的。</p><h2 id="Bukkit-源码部分"><a href="#Bukkit-源码部分" class="headerlink" title="Bukkit 源码部分"></a>Bukkit 源码部分</h2><p>可以在 <a href="https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/browse" target="_blank" rel="noopener">Bukkit</a> 这里找到它的源码。拿到源码后我们从 <code>registerEvents</code> 这里入手，看看它帮我们干了什么不可描述的事情。<code>PluginManager</code> 是个接口，需要到它的实现类 <code>SimplePluginManager</code> 中找。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEvents</span><span class="params">(Listener listener, Plugin plugin)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...省略那个插件是否启用的判断</span></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Class&lt;? extends Event&gt;, Set&lt;RegisteredListener&gt;&gt; entry :</span><br><span class="line">        plugin.getPluginLoader().createRegisteredListeners(listener, plugin).entrySet()) &#123;</span><br><span class="line">           getEventListeners(getRegistrationClass(entry.getKey()))</span><br><span class="line">           .registerAll(entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到关键在于掉用了 <code>createRegisteredListeners</code> 这个方法，然后把 <code>RegisteredListeners</code> 和 <code>Event</code> 对应交给 <code>HandlerList</code> 处理。（<code>createRegisteredListeners</code> 是 <code>PluginLoader</code> 接口的方法）同样，我们需要找他的实现类 <code>JavaPluginLoader</code>。这个方法有 87 行，这里简述一下其才做流程：</p><ul><li>拿到 <code>Listener</code> 实例后，用反射找里面的 <code>Method</code>；</li><li>找到 Method 后检验是否符合注册的标准，并且拿到其注解 <code>@EventHandler</code> 中的优先级；</li><li>对于被标注 <code>@Deprecated</code> 并符合要求的方法要在 logger 中打印出来，提醒使用者；</li><li>建立一个 <code>EventExecutor</code> 接口的匿名类实例，将方法 <code>execute</code> 重写，在其中调用反射找来的方法 (<code>method.invoke(listener, event)</code>)；</li><li>根据 <code>useTimings</code> 分别new 出 <code>TimedRegisteredListener</code> 或 <code>RegisteredListener</code>，并把它们加到与 <code>Event</code> 对应的 Map 中。</li></ul><p>交给 <code>HandlerList</code> 后，其中有一个 <code>EnumMap&lt;EventPriority, ArrayList&lt;RegisteredListener&gt;&gt;</code> 来保存每一个优先级对应的监听器，在 <code>PluginManager</code> 的 <code>fireEvent</code> 方法中调用。看到这我们大概了解了它的注册原理，<code>EventExecutor</code> 这个东西才是最关键的。我们回到 <code>PluginManager</code>，除了有 <code>registerEvents(Listener listener, Plugin plugin)</code> 外，还有两个注册方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEvent</span><span class="params">(Class&lt;? extends Event&gt; event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin)</span> </span>&#123;</span><br><span class="line">       registerEvent(event, listener, priority, executor, plugin, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEvent</span><span class="params">(Class&lt;? extends Event&gt; event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, <span class="keyword">boolean</span> ignoreCancelled)</span> </span>&#123;</span><br><span class="line">       Validate.notNull(listener, <span class="string">"Listener cannot be null"</span>);</span><br><span class="line">       Validate.notNull(priority, <span class="string">"Priority cannot be null"</span>);</span><br><span class="line">       Validate.notNull(executor, <span class="string">"Executor cannot be null"</span>);</span><br><span class="line">       Validate.notNull(plugin, <span class="string">"Plugin cannot be null"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!plugin.isEnabled()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalPluginAccessException(<span class="string">"Plugin attempted to register "</span> + event + <span class="string">" while not enabled"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (useTimings) &#123;</span><br><span class="line">           getEventListeners(event).register(<span class="keyword">new</span> TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           getEventListeners(event).register(<span class="keyword">new</span> RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对比一下刚才的 <code>registerEvents</code> ，我们发现它只是少了用反射找那些 method 的部分，并且让我们传入一个 <code>EventExecutor</code> 实例。这就很简单了，不过我一直没想明白为啥它还要求一个 <code>Listener</code> 实例。。。但是这不重要，传个空的就好，因为在 <code>RegisteredListener</code> 构造时也没有对 <code>Listener</code> 做出什么不可描述的事情。试着用一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pluginManager.registerEvent(PlayerJoinEvent::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">object : Listener &#123;&#125;</span>,<span class="type"></span></span></span><br><span class="line">EventPriority.NORMAL,</span><br><span class="line">&#123; _: Listener, e: Event -&gt; (e <span class="keyword">as</span> PlayerJoinEvent).player sendMessage <span class="string">"你好！"</span> &#125;,</span><br><span class="line">plugin</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里第三个参数应该是 <code>EventExecutor</code>，但此接口符合函数式接口的标准，Kotlin 帮我们 SAM 转换成 <code>(Listener,Event) -&gt; Unit</code>。写好后放到服务器里运行，发现插件可以正常工作，下面就可以开始写 DSL 语言结构了。</p><h2 id="DSL-构造事件监听器"><a href="#DSL-构造事件监听器" class="headerlink" title="DSL 构造事件监听器"></a>DSL 构造事件监听器</h2><p>与上篇说的命令相似，我们同样需要把监听器封装一下，让他持有注册时所需要的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">PackingEvent</span>&lt;<span class="type">in T : Event</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> type: Class&lt;<span class="keyword">out</span> Event&gt;,</span><br><span class="line">                                      <span class="keyword">private</span> <span class="keyword">val</span> eventPriority: EventPriority,</span><br><span class="line">                                      <span class="keyword">private</span> <span class="keyword">val</span> block: (T) -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line"><span class="meta">@Suppress(<span class="meta-string">"UNCHECKED_CAST"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">pluginManager.registerEvent(type, emptyListener, eventPriority,</span><br><span class="line">&#123; _: Listener, event -&gt;</span><br><span class="line">block(event <span class="keyword">as</span> T)</span><br><span class="line">&#125;, plugin)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中可以用数据类进行封装，不过没获得什么好处。因为我们传进去的是空 <code>Listener</code>，所以没必要再把一个空的拿回来。将 <code>event</code> cast 成 <code>T</code>，这里不用担心 cast 出错，因为注册的是什么事件，传进来的一定是想要的，类型不会错。有了 <code>PackingEvent</code>，就可以创造 Builder 了。但我们发现，与命令不同，注册事件没有那些可有可无的东西，并且只需要优先级和一个 <code>(T) -&gt; Unit</code>。这样就没有必要再写 Builder 了，直接写个 Scope：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventScope</span> </span>&#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Event&gt;</span> <span class="title">event</span><span class="params">(eventPriority: <span class="type">EventPriority</span> = EventPriority.NORMAL, <span class="keyword">noinline</span> block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">PackingEvent(T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">eventPriority</span>, <span class="type">block).let</span></span>(EventHolder::add)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个函数，为了获取泛型的类实例，要写成 <code>inline</code> + <code>reified</code>。但 <code>block : (T) -&gt; Unit</code> 会被存到 <code>PackingEvent</code> 中，并非原地调用，不能被编译器内联优化，所以 <code>block</code> 要加上关键字 <code>noinline</code>。</p><p>再把 Scope 开放出来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildEvents</span><span class="params">(block: <span class="type">EventScope</span>.() -&gt; <span class="type">Unit</span>)</span></span> =</span><br><span class="line">EventScope().block()</span><br></pre></td></tr></table></figure><p>然后就可以愉快的食用了，在插件启动时写上：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">buildEvents &#123;</span><br><span class="line">event&lt;PlayerJoinEvent&gt;(EventPriority.HIGH) &#123;</span><br><span class="line">player.sendMessage(ChatColor.GREEN+<span class="string">"欢迎加入!~"</span>)</span><br><span class="line">&#125;</span><br><span class="line">event&lt;PlayerBedLeaveEvent&gt; &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>event</code> 函数中直接写成了 <code>T.() -&gt; Unit</code> 并且 <code>apply(block)</code> 这个大括号的里面就相当于对应事件的类中，可以直接访问里面的公共成员。优先级上面定义了如果不声明默认是 <code>NORMAL</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是说几个问题：</p><ul><li>无法动态注册、取消注册</li><li>封装性欠缺</li></ul><p>同命令部分，大家可以自行摸索或参考一下 <a href="https://github.com/berberman/emerald" target="_blank" rel="noopener">emerald</a> 中的 <a href="https://github.com/berberman/emerald/tree/master/common/src/cn/berberman/emerald/event" target="_blank" rel="noopener">部分</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次介绍了如何在 Kotlin 语言中使用 DSL 构造注册命令，这篇来写一下注册事件监听器。&lt;/p&gt;
&lt;p&gt;注册监听器通常情况下都是用 &lt;code&gt;@EventHandler&lt;/code&gt; 标注一个方法，写在一个实现空接口 &lt;code&gt;Listener&lt;/code&gt; 的类中，像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; DemoListener : Listener &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@EventHandler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onPlayJoin&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(event: &lt;span class=&quot;type&quot;&gt;PlayerJoinEvent&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		event.player.sendMessage(ChatColor.AQUA + &lt;span class=&quot;string&quot;&gt;&quot;Hi!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在插件启动时写上：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pluginManager.registerEvents(DemoListener, plugin)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;就可以正常食用了。如果不通过注解反射实现呢？我们需要翻一下源码，看看他的底层是怎么实现的。&lt;/p&gt;
&lt;h2 id=&quot;Bukkit-源码部分&quot;&gt;&lt;a href=&quot;#Bukkit-源码部分&quot; class=&quot;headerlink&quot; title=&quot;Bukkit 源码部分&quot;&gt;&lt;/a&gt;Bukkit 源码部分&lt;/h2&gt;&lt;p&gt;可以在 &lt;a href=&quot;https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/browse&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bukkit&lt;/a&gt; 这里找到它的源码。拿到源码后我们从 &lt;code&gt;registerEvents&lt;/code&gt; 这里入手，看看它帮我们干了什么不可描述的事情。&lt;code&gt;PluginManager&lt;/code&gt; 是个接口，需要到它的实现类 &lt;code&gt;SimplePluginManager&lt;/code&gt; 中找。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Minecraft" scheme="https://berberman.cn/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft-Bukkit插件-DSL注册命令</title>
    <link href="https://berberman.cn/2018/01/30/minecraft-dsl-command/"/>
    <id>https://berberman.cn/2018/01/30/minecraft-dsl-command/</id>
    <published>2018-01-30T22:04:04.000Z</published>
    <updated>2020-08-13T10:39:10.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在食用本文前你需要了解 Kotlin语言，及用到的特性——带接收者的 lambda、内联 reified 泛型函数、扩展函数、中缀函数等。当然这些大部分都是在 Kotlin 中想要写出 DSL 语言结构的必要知识。</p><h2 id="DSL-构造命令"><a href="#DSL-构造命令" class="headerlink" title="DSL 构造命令"></a>DSL 构造命令</h2><p>关于注册命令的写法大部分都是远古判断法或者注解反射法。关于注解反射这个东西，虽然外表看起来简洁美观，但背后十分邪恶，我个人也非常不喜欢。因此我们从 <code>CommandMap</code> 注册命令开始入手。<br>首先需要拿到 <code>CommandMap</code>，它位于 <code>Server</code> 类中。</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getCommandMap</span><span class="params">()</span></span>: CommandMap =</span><br><span class="line">Bukkit.getServer().let &#123;</span><br><span class="line">it::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">declaredMethods</span>.<span class="title">firstOrNull</span> </span>&#123; it.name == <span class="string">"getCommandMap"</span> &#125;</span><br><span class="line">?.invoke(it) <span class="keyword">as</span> CommandMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处没有对非空做出处理，因为我们知道 <code>Server</code> 类中肯定是存在这个东西的。之后我们就要把抽象类 <code>Command</code> 给实现一下他的  <code>execute</code> 方法。在构造 DSL 过程中，我们把这个方法中执行的内容封装成一个 lambda <code>(CommandSender, String, Array&lt;out String&gt;) -&gt; Unit</code>，用 <code>result</code> 作为最终返回结果。我们定义一个类继承 <code>Command</code> ，并封装上下文及 <code>execute</code> 函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PackingCommand</span></span></span><br><span class="line">(name: String, description: String, usageMessage: String,</span><br><span class="line"> aliases: List&lt;String&gt;,</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> action: (CommandSender, String, Array&lt;<span class="keyword">out</span> String&gt;) -&gt; <span class="built_in">Unit</span>,</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> result: <span class="built_in">Boolean</span>) : Command(name, description, usageMessage, aliases)&#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">(p0: <span class="type">CommandSender</span>, p1: <span class="type">String</span>, p: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;)</span></span> =</span><br><span class="line">      result.apply &#123; action(p0, p1, p) &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>name</code>、<code>description</code>、<code>usageMessage</code>、<code>aliases</code> 对应 plugin.yml 下对命令的配置；</li><li><code>action</code> 会在 <code>execute</code> 被调用时执行</li><li><code>result</code> 对应处理命令时返回的布尔结果（这里在 runtime 前已经固定）</li></ul><p>定义完 <code>PackingCommand</code> 后，可以实现其 DSL Builder。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandBuilderDsl</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="comment">//下面这些成员都带有默认值，因为每项不是必要的，包括 `action`。</span></span><br><span class="line">    <span class="keyword">var</span> action: (CommandSender, String, Array&lt;<span class="keyword">out</span> String&gt;) -&gt; <span class="built_in">Unit</span> =</span><br><span class="line">      &#123; _, _, _ -&gt; <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span>   <span class="comment">//不让在外面修改，只能通过提供的函数赋值。</span></span><br><span class="line"><span class="keyword">var</span> description: String = <span class="string">""</span></span><br><span class="line"><span class="keyword">var</span> usageMessage: String = <span class="string">""</span></span><br><span class="line"><span class="keyword">val</span> aliases: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"><span class="keyword">var</span> result: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">action</span><span class="params">(block: (<span class="type">CommandSender</span>, <span class="type">String</span>, <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">action = block</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这里多提供一种赋值方法，因为 `label` 和 `args` 有时候不需要使用，每次都要写</span></span><br><span class="line">    <span class="comment">// `&#123; sender, _, _ -&gt; &#125;` 太麻烦。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">action</span><span class="params">(block: (<span class="type">CommandSender</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">action = &#123; sender, _, _ -&gt; block(sender) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAlias</span><span class="params">(alias: <span class="type">String</span>)</span></span> = aliases.add(alias)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完 <code>CommandBuilderDsl</code> 后还需要提供一另一个 <code>CommandScope</code> 来构造 <code>Builder</code>，在这之前构造好的 <code>Command</code> 需要存起来，在插件启用时调用，这部分不贴代码了，就是一个 <code>MutableList&lt;PackingCommand&gt;</code>，向外提供注册方法。<code>CommandScope</code> 的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandScopeDsl</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">command</span><span class="params">(name: <span class="type">String</span>, block: <span class="type">CommandBuilderDsl</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">CommandBuilderDsl(name).apply(block).apply &#123;</span><br><span class="line">PackingCommand(<span class="keyword">this</span>.name, description, usageMessage, aliases, action, result)</span><br><span class="line">.let(CommandHolder::add)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前 <code>CommandScope</code> 中就一个函数，也可以省略 <code>CommandScope</code>，直接将 <code>command()</code> 改为顶层函数，不过未来肯定还会加东西，而且这样写是不合理的。贴一下前面的注册方法，<code>commands</code> 是那个持有 <code>PackingCommand</code> 的 list：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(commandMap: <span class="type">CommandMap</span>)</span></span> &#123;</span><br><span class="line">commands.forEach &#123;</span><br><span class="line">commandMap.register(<span class="string">"DemoPlugin"</span>, it <span class="keyword">as</span> Command)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再加上把 <code>CommandScope</code> 开放出来的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">buildCommands</span><span class="params">(block: <span class="type">CommandScope</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">CommandScope().apply(block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就完成了，在插件启用时调用 <code>CommandHolder.register(getCommandMap())</code> 注册就好。<br>随便写个命令举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildCommands &#123;</span><br><span class="line">command(<span class="string">"gg"</span>) &#123;</span><br><span class="line">action &#123; sender -&gt;</span><br><span class="line">sender.sendMessage(<span class="string">"233"</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">command(<span class="string">"..."</span>)&#123;</span><br><span class="line">action&#123;sender-&gt;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有几个问题：</p><ul><li>命令多了看起来很乱，大括号越写越多</li><li>封装性欠缺</li><li>无法美观处理子命令</li></ul><p>除了第一个问题是 Kotlin DSL 的硬伤外，其余都可以自己慢慢优化、实现。<a href="https://github.com/berberman/emerald" target="_blank" rel="noopener">emerald</a> 主要思想来源于本文，可以在 <a href="https://github.com/berberman/emerald/tree/master/common/src/cn/berberman/emerald/command" target="_blank" rel="noopener">这里</a> 找到我进一步封装的代码。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在食用本文前你需要了解 Kotlin语言，及用到的特性——带接收者的 lambda、内联 reified 泛型函数、扩展函数、中缀函数等。当然这些大部分都是在 Kotlin 中想要写出 DSL 语言结构的必要知识。&lt;/p&gt;
&lt;h2 id=&quot;DSL-构造命令&quot;&gt;&lt;a href=&quot;#DSL-构造命令&quot; class=&quot;headerlink&quot; title=&quot;DSL 构造命令&quot;&gt;&lt;/a&gt;DSL 构造命令&lt;/h2&gt;&lt;p&gt;关于注册命令的写法大部分都是远古判断法或者注解反射法。关于注解反射这个东西，虽然外表看起来简洁美观，但背后十分邪恶，我个人也非常不喜欢。因此我们从 &lt;code&gt;CommandMap&lt;/code&gt; 注册命令开始入手。&lt;br&gt;首先需要拿到 &lt;code&gt;CommandMap&lt;/code&gt;，它位于 &lt;code&gt;Server&lt;/code&gt; 类中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Minecraft" scheme="https://berberman.cn/tags/Minecraft/"/>
    
  </entry>
  
</feed>
