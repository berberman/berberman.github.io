<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Minecraft-Bukkit插件-插件类加载器</title>
      <link href="/2018/05/08/minecraft-plugin-classloader/"/>
      <url>/2018/05/08/minecraft-plugin-classloader/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发 Bukkit 插件库的过程中，有时会需要用到插件主类实例的情况。举一个栗子：</p><pre><code class="kotlin">registerEventListeners(this) {    event&lt;PlayerJoinEvent&gt; {        player.sendMessage(&quot;Hello!&quot;)    }}</code></pre><p>因为事件监听器的注册需要绑定在插件上，对于库/前置插件开发者来说，需要每次用到插件实例时让调用者提供。看起来没什么不对的，但这里有一个更好的方法。我们先来一波分析。</p><h2 id="插件注册分析"><a href="#插件注册分析" class="headerlink" title="插件注册分析"></a>插件注册分析</h2><p>服务器插件的加载是由 <code>CraftServer</code> 的 <code>loadPlugins</code> 开始的。</p><pre><code class="java">public final class CraftServer implements Server {    public void loadPlugins() {        this.pluginManager.registerInterface(JavaPluginLoader.class);        File pluginFolder = (File)this.console.options.valueOf(&quot;plugins&quot;);        if (pluginFolder.exists()) {            Plugin[] plugins = this.pluginManager.loadPlugins(pluginFolder);            Plugin[] var6 = plugins;            int var5 = plugins.length;            for(int var4 = 0; var4 &lt; var5; ++var4) {                Plugin plugin = var6[var4];                try {                    String message = String.format(&quot;Loading %s&quot;, plugin.getDescription().getFullName());                    plugin.getLogger().info(message);                    plugin.onLoad();                } catch (Throwable var8) {                    Logger.getLogger(CraftServer.class.getName()).log(Level.SEVERE, var8.getMessage() + &quot; initializing &quot; + plugin.getDescription().getFullName() + &quot; (Is it up to date?)&quot;, var8);                }            }        } else {            pluginFolder.mkdir();        }    }}</code></pre><p>首先，<code>CraftServer</code> 调用了其内部持有的 <code>SimplePluginManager</code> 的 <code>registerInterface(JavaPluginLoader.class)</code> 方法</p><pre><code class="java">public final class SimplePluginManager implements PluginManager {    public void registerInterface(Class&lt;? extends PluginLoader&gt; loader) throws IllegalArgumentException {        PluginLoader instance;        if (PluginLoader.class.isAssignableFrom(loader)) {            Constructor&lt;? extends PluginLoader&gt; constructor;            try {                constructor = loader.getConstructor(Server.class);                instance = constructor.newInstance(server);            } catch (NoSuchMethodException ex) {                String className = loader.getName();                throw new IllegalArgumentException(String.format(&quot;Class %s does not have a public %s(Server) constructor&quot;, className, className), ex);            } catch (Exception ex) {                throw new IllegalArgumentException(String.format(&quot;Unexpected exception %s while attempting to construct a new instance of %s&quot;, ex.getClass().getName(), loader.getName()), ex);            }        } else {            throw new IllegalArgumentException(String.format(&quot;Class %s does not implement interface PluginLoader&quot;, loader.getName()));        }        Pattern[] patterns = instance.getPluginFileFilters();        synchronized (this) {            for (Pattern pattern : patterns) {                fileAssociations.put(pattern, instance);            }        }    }}</code></pre><p>这一步<code>SimplePluginManager</code> 负责 new 出 <code>JavaPluginLoader</code> 的实例，并且将插件名字过滤正则与 <code>JavaPluginLoader</code> 实例对应。（默认情况下 <code>PluginLoader</code> 接口仅有一个实现类 <code>JavaPluginLoader</code>）</p><pre><code class="java">public final class JavaPluginLoader implements PluginLoader {    private final Pattern[] fileFilters = [Pattern.compile(&quot;\\.jar$&quot;)];}</code></pre><p> <code>JavaPluginLoader</code> 只含有一个正则表达式，用于过滤插件文件夹中的文件。<br>接着，<code>CraftServer</code> 会调用 <code>SimplePluginManager</code> 的 <code>loadPlugins(File)</code> 方法。</p><pre><code class="java">    public Plugin[] loadPlugins(File directory) {        Validate.notNull(directory, &quot;Directory cannot be null&quot;);        Validate.isTrue(directory.isDirectory(), &quot;Directory must be a directory&quot;);        List&lt;Plugin&gt; result = new ArrayList&lt;Plugin&gt;();        Set&lt;Pattern&gt; filters = fileAssociations.keySet();        if (!(server.getUpdateFolder().equals(&quot;&quot;))) {            updateDirectory = new File(directory, server.getUpdateFolder());        }        Map&lt;String, File&gt; plugins = new HashMap&lt;String, File&gt;();        Set&lt;String&gt; loadedPlugins = new HashSet&lt;String&gt;();        Map&lt;String, Collection&lt;String&gt;&gt; dependencies = new HashMap&lt;String, Collection&lt;String&gt;&gt;();        Map&lt;String, Collection&lt;String&gt;&gt; softDependencies = new HashMap&lt;String, Collection&lt;String&gt;&gt;();        // This is where it figures out all possible plugins        for (File file : directory.listFiles()) {            PluginLoader loader = null;            for (Pattern filter : filters) {                Matcher match = filter.matcher(file.getName());                if (match.find()) {                    loader = fileAssociations.get(filter);                }            }            if (loader == null) continue;            PluginDescriptionFile description = null;            try {                description = loader.getPluginDescription(file);                String name = description.getName();                if (name.equalsIgnoreCase(&quot;bukkit&quot;) || name.equalsIgnoreCase(&quot;minecraft&quot;) || name.equalsIgnoreCase(&quot;mojang&quot;)) {                    server.getLogger().log(Level.SEVERE, &quot;Could not load &#39;&quot; + file.getPath() + &quot;&#39; in folder &#39;&quot; + directory.getPath() + &quot;&#39;: Restricted Name&quot;);                    continue;                } else if (description.rawName.indexOf(&#39; &#39;) != -1) {                    server.getLogger().log(Level.SEVERE, &quot;Could not load &#39;&quot; + file.getPath() + &quot;&#39; in folder &#39;&quot; + directory.getPath() + &quot;&#39;: uses the space-character (0x20) in its name&quot;);                    continue;                }            } catch (InvalidDescriptionException ex) {                server.getLogger().log(Level.SEVERE, &quot;Could not load &#39;&quot; + file.getPath() + &quot;&#39; in folder &#39;&quot; + directory.getPath() + &quot;&#39;&quot;, ex);                continue;            }            File replacedFile = plugins.put(description.getName(), file);            if (replacedFile != null) {                server.getLogger().severe(String.format(                    &quot;Ambiguous plugin name `%s&#39; for files `%s&#39; and `%s&#39; in `%s&#39;&quot;,                    description.getName(),                    file.getPath(),                    replacedFile.getPath(),                    directory.getPath()                ));            }        //省去通过依赖分析来决定加载顺序。        return result.toArray(new Plugin[result.size()]);    }</code></pre><p>该方法会找到目录下所有 jar 文件，并调用 <code>JavaPluginLoader</code> 的 <code>getPluginDescription(File)</code> 方法，找到目录下所有插件的描述文件。下一步会根据 <code>softDependency</code> 和 <code>dependency</code> 处理各个插件的加载顺序，并进行一系列的合法性校验，并对每个合法文件调用 <code>loadPlugin(File)</code> 方法。</p><pre><code class="java">public final class SimplePluginManager implements PluginManager {    public synchronized Plugin loadPlugin(File file) throws InvalidPluginException, UnknownDependencyException {        Validate.notNull(file, &quot;File cannot be null&quot;);        checkUpdate(file);        Set&lt;Pattern&gt; filters = fileAssociations.keySet();        Plugin result = null;    for (Pattern filter : filters) {        String name = file.getName();        Matcher match = filter.matcher(name);        if (match.find()) {            PluginLoader loader = fileAssociations.get(filter);            result = loader.loadPlugin(file);        }    }    if (result != null) {        plugins.add(result);        lookupNames.put(result.getDescription().getName(), result);    }    return result;}</code></pre><p>当正则匹配时，方法调用了 <code>fileAssociations</code> 中存的 loader，也就是 <code>JavaPluginLoader</code> 的 <code>loadPlugin(File)</code> 方法。</p><pre><code class="java">public final class JavaPluginLoader implements PluginLoader {    public Plugin loadPlugin(final File file) throws InvalidPluginException {        Validate.notNull(file, &quot;File cannot be null&quot;);        if (!file.exists()) {            throw new InvalidPluginException(new FileNotFoundException(file.getPath() + &quot; does not exist&quot;));        }        final PluginDescriptionFile description;        try {            description = getPluginDescription(file);        } catch (InvalidDescriptionException ex) {            throw new InvalidPluginException(ex);        }        final File parentFile = file.getParentFile();        final File dataFolder = new File(parentFile, description.getName());        @SuppressWarnings(&quot;deprecation&quot;)        final File oldDataFolder = new File(parentFile, description.getRawName());        // Found old data folder        if (dataFolder.equals(oldDataFolder)) {            // They are equal -- nothing needs to be done!        } else if (dataFolder.isDirectory() &amp;&amp; oldDataFolder.isDirectory()) {            server.getLogger().warning(String.format(                &quot;While loading %s (%s) found old-data folder: `%s&#39; next to the new one `%s&#39;&quot;,                description.getFullName(),                file,                oldDataFolder,                dataFolder            ));        } else if (oldDataFolder.isDirectory() &amp;&amp; !dataFolder.exists()) {            if (!oldDataFolder.renameTo(dataFolder)) {                throw new InvalidPluginException(&quot;Unable to rename old data folder: `&quot; + oldDataFolder + &quot;&#39; to: `&quot; + dataFolder + &quot;&#39;&quot;);            }            server.getLogger().log(Level.INFO, String.format(                &quot;While loading %s (%s) renamed data folder: `%s&#39; to `%s&#39;&quot;,                description.getFullName(),                file,                oldDataFolder,                dataFolder            ));        }        if (dataFolder.exists() &amp;&amp; !dataFolder.isDirectory()) {            throw new InvalidPluginException(String.format(                &quot;Projected datafolder: `%s&#39; for %s (%s) exists and is not a directory&quot;,                dataFolder,                description.getFullName(),                file            ));        }        for (final String pluginName : description.getDepend()) {            Plugin current = server.getPluginManager().getPlugin(pluginName);            if (current == null) {                throw new UnknownDependencyException(pluginName);            }        }        final PluginClassLoader loader;        try {            loader = new PluginClassLoader(this, getClass().getClassLoader(), description, dataFolder, file);        } catch (InvalidPluginException ex) {            throw ex;        } catch (Throwable ex) {            throw new InvalidPluginException(ex);        }        loaders.add(loader);        return loader.plugin;    }}</code></pre><p>这里对插件数据文件夹进行诸如创建之类的操作，并且检测当前插件的依赖是否全部已经被加载。接下来最重要的一步为 new 出 <code>PluginClassLoader</code>。</p><pre><code class="java">final class PluginClassLoader extends URLClassLoader {    PluginClassLoader(final JavaPluginLoader loader, final ClassLoader parent, final PluginDescriptionFile description, final File dataFolder, final File file) throws IOException, InvalidPluginException, MalformedURLException {        super(new URL[] {file.toURI().toURL()}, parent);        Validate.notNull(loader, &quot;Loader cannot be null&quot;);        this.loader = loader;        this.description = description;        this.dataFolder = dataFolder;        this.file = file;        this.jar = new JarFile(file);        this.manifest = jar.getManifest();        this.url = file.toURI().toURL();        try {            Class&lt;?&gt; jarClass;            try {                jarClass = Class.forName(description.getMain(), true, this);            } catch (ClassNotFoundException ex) {                throw new InvalidPluginException(&quot;Cannot find main class `&quot; + description.getMain() + &quot;&#39;&quot;, ex);            }            Class&lt;? extends JavaPlugin&gt; pluginClass;            try {                pluginClass = jarClass.asSubclass(JavaPlugin.class);            } catch (ClassCastException ex) {                throw new InvalidPluginException(&quot;main class `&quot; + description.getMain() + &quot;&#39; does not extend JavaPlugin&quot;, ex);            }            plugin = pluginClass.newInstance();        } catch (IllegalAccessException ex) {            throw new InvalidPluginException(&quot;No public constructor&quot;, ex);        } catch (InstantiationException ex) {            throw new InvalidPluginException(&quot;Abnormal plugin type&quot;, ex);        }    }}</code></pre><p><code>PluginClassLoader</code> 构造器中校验插件主类，并使用反射在本类加载器下创建实例。</p><pre><code class="java">public abstract class JavaPlugin extends PluginBase {    public JavaPlugin() {    final ClassLoader classLoader = this.getClass().getClassLoader();    if (!(classLoader instanceof PluginClassLoader)) {            throw new IllegalStateException(&quot;JavaPlugin requires &quot; + PluginClassLoader.class.getName());        }        ((PluginClassLoader) classLoader).initialize(this);    }}</code></pre><p>在 <code>JavaPlugin</code> 的构造器中，其调用了 <code>PluginClassLoader</code> 的 <code>initialize(JavaPlugin)</code> 方法。</p><pre><code class="java">final class PluginClassLoader extends URLClassLoader {    synchronized void initialize(JavaPlugin javaPlugin) {        Validate.notNull(javaPlugin, &quot;Initializing plugin cannot be null&quot;);        Validate.isTrue(javaPlugin.getClass().getClassLoader() == this, &quot;Cannot initialize plugin outside of this class loader&quot;);        if (this.plugin != null || this.pluginInit != null) {            throw new IllegalArgumentException(&quot;Plugin already initialized!&quot;, pluginState);        }        pluginState = new IllegalStateException(&quot;Initial initialization&quot;);        this.pluginInit = javaPlugin;        javaPlugin.init(loader, loader.server, description, dataFolder, file, this);    }}</code></pre><p><del>为了便于抛出异常，<code>pluginState</code> 成员听起来像是枚举的类型，可它实际是是 <code>IllegalArgumentException</code>，我觉得布星。</del><br>这里 <code>initialize(JavaPlugin)</code> 又调用了 <code>JavaPlugin</code> 的init(PluginLoader, Server, PluginDescriptionFile, File, File, ClassLoader)</p><pre><code class="java">public abstract class JavaPlugin extends PluginBase {    final void init(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {        this.loader = loader;        this.server = server;        this.file = file;        this.description = description;        this.dataFolder = dataFolder;        this.classLoader = classLoader;        this.configFile = new File(dataFolder, &quot;config.yml&quot;);        this.logger = new PluginLogger(this);    }}</code></pre><p>该方法传入了一些参数，供插件编写者使用。至此，一个插件就加载好了。</p><h2 id="大雾"><a href="#大雾" class="headerlink" title="大雾"></a>大雾</h2><p><del>为了扣题表达</del> 了解一个插件是如何被加载后，我们可以从属于该插件代码内的任何一个实例获取插件主类的实例。直接上代码：</p><pre><code class="java">class Jaba {    public static JavaPlugin jaba(Object object) {        ClassLoader classLoader = object.getClass().getClassLoader();        try {            Class&lt;?&gt; loaderClass = Class.forName(&quot;org.bukkit.plugin.java.PluginClassLoader&quot;);            if(!loaderClass.isInstance(classLoader))                throw new IllegalPluginAccessException();            Field pluginField = loaderClass.getField(&quot;plugin&quot;);            pluginField.setAccessible(true);            return (JavaPlugin) pluginField.get(classLoader);        } catch(ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) {            throw new IllegalPluginAccessException(e.getMessage());        }    }}</code></pre><p><del>至少 7 个月没写 Java 了，十分不习惯。</del> 万恶的 <code>PluginClassLoader</code> 是 package-private 的，所以需要通过反射访问。只是这段代码是 100% 不可能用到的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如有错误，欢迎指出，毕竟我太菜了。</p>]]></content>
      
      <categories>
          
          <category> Minecraft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minecraft-Bukkit插件-DSL注册事件监听器</title>
      <link href="/2018/01/31/minecraft-dsl-event/"/>
      <url>/2018/01/31/minecraft-dsl-event/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次介绍了怎么写一个 DSL 语言结构注册命令，这篇来写一下注册事件监听器。</p><h2 id="一般的注册的方法"><a href="#一般的注册的方法" class="headerlink" title="一般的注册的方法"></a>一般的注册的方法</h2><p>基本上注册监听器都是用 <code>@EventHandler</code> 标注一个方法，写在一个实现空接口 <code>Listener</code> 的类中，像这样：</p><pre><code class="kotlin">object DemoListener : Listener {    @EventHandler    fun onPlayJoin(event: PlayerJoinEvent) {        event.player.sendMessage(ChatColor.AQUA + &quot;Hi!&quot;)    }}</code></pre><p>在插件启动时写上：</p><pre><code class="kotlin">pluginManager.registerEvents(DemoListener, plugin)</code></pre><p>就可以正常食用了。如果不通过注解反射实现呢？我们需要翻一下源码，看看他的底层是怎么实现的。</p><h2 id="Bukkit-源码部分"><a href="#Bukkit-源码部分" class="headerlink" title="Bukkit 源码部分"></a>Bukkit 源码部分</h2><hr><p>你可以在 <a href="https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/browse" target="_blank" rel="noopener">Bukkit</a> 这里找到 Bukkit 的源码。拿到源码后我们从 <code>registerEvents</code> 这里入手，看看它帮我们干了什么不可描述的事情。<code>PluginManager</code> 是个接口，需要到它的实现类 <code>SimplePluginManager</code> 中找。</p><pre><code class="java">public void registerEvents(Listener listener, Plugin plugin) {        //...省略那个插件是否启用的判断       for (Map.Entry&lt;Class&lt;? extends Event&gt;, Set&lt;RegisteredListener&gt;&gt; entry :        plugin.getPluginLoader().createRegisteredListeners(listener, plugin).entrySet()) {           getEventListeners(getRegistrationClass(entry.getKey()))           .registerAll(entry.getValue());       }   }</code></pre><p>可以看到这的关键就是掉了 <code>createRegisteredListeners</code> 这个方法，然后把 <code>RegisteredListeners</code> 和 <code>Event</code> 对应交给 <code>HandlerList</code> 处理。<code>createRegisteredListeners</code> 这玩意是 <code>PluginLoader</code> 接口的方法，同样，我们需要找他的实现类 <code>JavaPluginLoader</code>。这个方法有 87 行，贴出来太占地，我大概说一下他干了啥：</p><ul><li><p>拿到 <code>Listener</code> 实例后，用反射找里面的 Method</p></li><li><p>找到 Method 后检验是否符合注册的标准，并且拿到其注解 <code>@EventHandler</code> 中的优先级</p></li><li><p>对于被标注 <code>@Deprecated</code> 并符合要求的方法要在 logger 中打印出来，告诉你已经过时了</p></li><li><p>建立一个 <code>EventExecutor</code> 接口的匿名类实例，将方法 <code>execute</code> 重写，在其中调用反射找来的方法 (<code>method.invoke(listener, event)</code>)</p></li><li><p>根据 <code>useTimings</code> 分别new 出 <code>TimedRegisteredListener</code> 或 <code>RegisteredListener</code>，并把它们加到与 <code>Event</code> 对应的 Map 中</p></li></ul><p>交给 <code>HandlerList</code> 后，其中有一个 <code>EnumMap&lt;EventPriority, ArrayList&lt;RegisteredListener&gt;&gt;</code> 来保存每一个优先级对应的监听器，在 <code>PluginManager</code> 的 <code>fireEvent</code> 方法中调用。看到这我们大概了解了它的注册原理，<code>EventExecutor</code> 这个东西才是最关键的。我们回到 <code>PluginManager</code>，除了有 <code>registerEvents(Listener listener, Plugin plugin)</code> 外，还有两个注册方法：</p><pre><code class="java">public void registerEvent(Class&lt;? extends Event&gt; event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin) {       registerEvent(event, listener, priority, executor, plugin, false);   }   public void registerEvent(Class&lt;? extends Event&gt; event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled) {       Validate.notNull(listener, &quot;Listener cannot be null&quot;);       Validate.notNull(priority, &quot;Priority cannot be null&quot;);       Validate.notNull(executor, &quot;Executor cannot be null&quot;);       Validate.notNull(plugin, &quot;Plugin cannot be null&quot;);       if (!plugin.isEnabled()) {           throw new IllegalPluginAccessException(&quot;Plugin attempted to register &quot; + event + &quot; while not enabled&quot;);       }       if (useTimings) {           getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));       } else {           getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));       }   }</code></pre><p>对比一下刚才的 <code>registerEvents</code> ，我们发现它只是少了用反射找那些 method 的部分，并且让我们传入一个 <code>EventExecutor</code> 实例。这就很简单了，不过我一直没想明白为啥它还要求一个 <code>Listener</code> 实例。。。但是这不重要，传个空的就好，反正在 <code>RegisteredListener</code> 构造时也没有对 <code>Listener</code> 做出什么不可描述的事情。试着用一下：</p><pre><code class="kotlin">pluginManager.registerEvent(PlayerJoinEvent::class.java, object : Listener {},                EventPriority.NORMAL,                { _: Listener, e: Event -&gt; (e as PlayerJoinEvent).player sendMessage &quot;你好！&quot; },                plugin        )</code></pre><p>这里第三个参数应该是 <code>EventExecutor</code>，但此接口符合函数式接口的标准，kotlin 帮我们 SAM 转换成 <code>(Listener,Event)-&gt;Unit</code>。写好后放到服务器里运行，发现插件可以正常工作，下面就可以开始写 DSL 语言结构了。</p><h2 id="DSL-构造事件监听器"><a href="#DSL-构造事件监听器" class="headerlink" title="DSL 构造事件监听器"></a>DSL 构造事件监听器</h2><p>与上篇说的命令相似，我们同样需要把监听器封装一下，让他持有注册时所需要的参数：</p><pre><code class="kotlin">data class PackingEvent&lt;in T : Event&gt;(private val type: Class&lt;out Event&gt;,                                      private val eventPriority: EventPriority,                                      private val block: (T) -&gt; Unit) {    @Suppress(&quot;UNCHECKED_CAST&quot;)    fun register() {        pluginManager.registerEvent(type, emptyListener, eventPriority,                { _: Listener, event -&gt;                    block(event as T)                }, plugin)    }}</code></pre><p>kotlin 可以写个数据类，不过没什么卵用。因为我们传进去的是空 <code>Listener</code>，所以没必要再把一个空的拿回来。用泛型 cast 一下，不用担心 cast 出错，因为你注册的是什么事件，传进来的一定是你想要的事件。有了 <code>PackingEvent</code>，就可以创造 Builder 了。但我们发现，与命令不同，注册事件没有那些可有可无的东西，并且只需要优先级和一个 <code>(T) -&gt; Unit</code>。这样就没有必要再写 Builder 了，直接写个 Scope：</p><pre><code class="kotlin">class EventScope {    inline fun &lt;reified T : Event&gt; event(eventPriority: EventPriority = EventPriority.NORMAL, noinline block: T.() -&gt; Unit) {        PackingEvent(T::class.java, eventPriority, block).let(EventHolder::add)    }}</code></pre><p>只有一个函数，为了获取泛型的类实例，要写成 inline + reified，但又要把 <code>(T) -&gt; Unit</code>，存起来，所以 <code>block</code> 要加上关键字 <code>noinline</code>，被编译器优化后，不会创建实例。</p><p>再把 Scope 开放出来：</p><pre><code class="kotlin">fun buildEvents(block: EventScope.() -&gt; Unit) =    EventScope().block()</code></pre><p>然后就可以愉快的食用了，在插件启动时写上：</p><pre><code class="kotlin">buildEvents {    event&lt;PlayerJoinEvent&gt;(EventPriority.HIGH) {        player.sendMessage(ChatColor.GREEN+&quot;欢迎加入!~&quot;)    }    event&lt;PlayerBedLeaveEvent&gt; {        //xxx    }}</code></pre><p><code>event</code> 函数中直接写成了 <code>T.() -&gt; Unit</code> 并且 <code>apply(block)</code> 这个大括号的里面就相当于对应事件的类中，可以直接访问里面的公共成员。优先级上面定义了如果不声明默认是 <code>NORMAL</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是说几个问题：</p><ul><li>无法动态注册、取消注册</li><li>封装性欠缺</li></ul><p>同命令部分，大家可以自行摸索或参考一下 <a href="https://github.com/berberman/emerald" target="_blank" rel="noopener">emerald</a> 中的 <a href="https://github.com/berberman/emerald/tree/master/common/src/cn/berberman/emerald/event" target="_blank" rel="noopener">部分</a>。</p>]]></content>
      
      <categories>
          
          <category> Minecraft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minecraft-Bukkit插件-DSL注册命令</title>
      <link href="/2018/01/30/minecraft-dsl-command/"/>
      <url>/2018/01/30/minecraft-dsl-command/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在食用本文前你需要了解 Kotlin语言，及用到的特性——带接收者的 lambda、内联 reified 泛型函数、扩展函数、中缀函数等。当然这些大部分都是在 Kotlin 中想要写出 DSL 语言结构的必要知识。</p><h2 id="DSL-构造命令"><a href="#DSL-构造命令" class="headerlink" title="DSL 构造命令"></a>DSL 构造命令</h2><p>关于注册命令的写法大部分都是远古判断法或者注解反射法。关于注解反射这个东西，虽然很简洁美观，但我个人是不喜欢的。就好比你追一个人一样，你不主动找人家，等着人家来遍历你，还得各种检测你。<del>(误)</del>  废话不说了，从 <code>CommandMap</code> 注册命令开始入手。<br>首先需要拿到 <code>CommandMap</code>，它位于 <code>Server</code> 类中。</p><pre><code class="kotlin">fun getCommandMap(): CommandMap =        Bukkit.getServer().let {            it::class.java.declaredMethods.firstOrNull { it.name == &quot;getCommandMap&quot; }                    ?.invoke(it) as CommandMap        }</code></pre><p>此处没有对非空做出处理，因为我们知道 <code>Server</code> 类中肯定是存在这个东西的。之后我们就要把抽象类 <code>Command</code> 给实现一下他的  <code>execute</code> 方法。在构造 DSL 过程中，我们把这个方法中执行的内容封装成一个 lambda <code>(CommandSender, String, Array&lt;out String&gt;) -&gt; Unit</code>，用<code>result</code> 作为最终返回结果。我们定义一个类来继承 <code>Command</code> 并承载这些东西。</p><pre><code class="kotlin">class PackingCommand(name: String, description: String, usageMessage: String, aliases: List&lt;String&gt;, private val action: (CommandSender, String, Array&lt;out String&gt;) -&gt; Unit, private val result: Boolean) : Command(name, description, usageMessage, aliases){   override fun execute(p0: CommandSender, p1: String, p: Array&lt;out String&gt;) =      result.apply { action(p0, p1, p) } }</code></pre><p>定义完了 <code>PackingCommand</code> 后，就该写他的 DSL Builder 了。代码如下：</p><pre><code class="kotlin">class CommandBuilderDsl(val name: String) {    //下面这些成员都带有默认值，因为每项不是必要的，包括 `action`。    var action: (CommandSender, String, Array&lt;out String&gt;) -&gt; Unit =      { _, _, _ -&gt; true }        private set   //不让在外面修改，只能通过提供的函数赋值。    var description: String = &quot;&quot;    var usageMessage: String = &quot;&quot;    val aliases: MutableList&lt;String&gt; = mutableListOf()    var result: Boolean = true    fun action(block: (CommandSender, String, Array&lt;out String&gt;) -&gt; Unit) {        action = block    }    //这里多提供一种赋值方法，因为 `label` 和 `args` 有时候不需要使用，每次都要写     `{ sender, _, _ -&gt; }` 太麻烦。    fun action(block: (CommandSender) -&gt; Unit) {        action = { sender, _, _ -&gt; block(sender) }    }    fun addAlias(alias: String) = aliases.add(alias)}</code></pre><p>写完 <code>CommandBuilderDsl</code> 后还需要提供一另一个 <code>CommandScope</code> 来构造 <code>Builder</code>，在这之前构造好的 <code>Command</code> 需要存起来，在插件启用时调用，这部分不贴代码了，就是一个<code>MutableList&lt;PackingCommand&gt;</code>，有个注册方法。<code>CommandScope</code> 的代码如下：</p><pre><code class="kotlin">class CommandScopeDsl {    fun command(name: String, block: CommandBuilderDsl.() -&gt; Unit) {        CommandBuilderDsl(name).apply(block).apply {            PackingCommand(this.name, description, usageMessage, aliases, action, result)                    .let(CommandHolder::add)        }    }}</code></pre><p>目前 <code>CommandScope</code> 中就一个函数，也可以省略 <code>CommandScope</code>，直接将 <code>command()</code> 改为顶层函数，不过未来肯定还会加东西，而且这样写是不合理的。贴一下前面的注册方法，<code>commands</code> 是那个持有 <code>PackingCommand</code> 的 list：</p><pre><code class="kotlin">fun register(commandMap: CommandMap) {        commands.forEach {            commandMap.register(&quot;DemoPlugin&quot;, it as Command)        }    }</code></pre><p>再加上把 <code>CommandScope</code> 开放出来的函数：</p><pre><code class="kotlin">fun buildCommands(block: CommandScope.() -&gt; Unit) {    CommandScope().apply(block)}</code></pre><p>至此就完成了，在插件启用时调用 <code>CommandHolder.register(getCommandMap())</code> 注册就好。<br>随便写个命令：</p><pre><code class="kotlin">buildCommands {    command(&quot;gg&quot;) {        action { sender -&gt;            sender.sendMessage(&quot;233&quot;)            true        }    }    command(&quot;xxx&quot;){        action{sender-&gt;            //xxxx        }    }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有几个问题：</p><ul><li>命令多了看起来很乱，大括号越写越多</li><li>封装性欠缺</li><li>无法美观处理子命令</li></ul><p>除了第一个问题是 Kotlin DSL 的硬伤外，其余都可以自己慢慢优化、实现。<a href="https://github.com/berberman/emerald" target="_blank" rel="noopener">emerald</a> 主要思想来源于本文，可以在 <a href="https://github.com/berberman/emerald/tree/master/common/src/cn/berberman/emerald/command" target="_blank" rel="noopener">这里</a> 找到我进一步封装的代码。</p>]]></content>
      
      <categories>
          
          <category> Minecraft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<pre><code class="kotlin">val berberman = Boy().apply{  name = &quot;berberman&quot;  location = Location.Beijing  contacts.putAll(hashMapOf(    &quot;Email&quot; to &quot;potato@berberman.cn&quot;,    &quot;Telegram&quot; to &quot;@berberman&quot;    ))}</code></pre><h2 id="何人甚于鄙之鶸乎"><a href="#何人甚于鄙之鶸乎" class="headerlink" title="何人甚于鄙之鶸乎"></a><strong>何人甚于鄙之鶸乎</strong></h2>]]></content>
    </entry>
    
  
</search>
