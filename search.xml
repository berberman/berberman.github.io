<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Minecraft-Bukkit插件-DSL注册事件监听器</title>
      <link href="/2018/01/31/minecraft-dsl-event/"/>
      <url>/2018/01/31/minecraft-dsl-event/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次介绍了怎么写一个 DSL 语言结构注册命令，这篇来写一下注册事件监听器。</p><h2 id="一般的注册的方法"><a href="#一般的注册的方法" class="headerlink" title="一般的注册的方法"></a>一般的注册的方法</h2><p>基本上注册监听器都是用 <code>@EventHandler</code> 标注一个方法，写在一个实现空接口 <code>Listener</code> 的类中，像这样：</p><pre><code class="kotlin">object DemoListener : Listener {    @EventHandler    fun onPlayJoin(event: PlayerJoinEvent) {        event.player.sendMessage(ChatColor.AQUA + &quot;Hi!&quot;)    }}</code></pre><p>在插件启动时写上：</p><pre><code class="kotlin">pluginManager.registerEvents(DemoListener, plugin)</code></pre><p>就可以正常食用了。如果不通过注解反射实现呢？我们需要翻一下源码，看看他的底层是怎么实现的。</p><h2 id="Bukkit-源码部分"><a href="#Bukkit-源码部分" class="headerlink" title="Bukkit 源码部分"></a>Bukkit 源码部分</h2><hr><p>你可以在 <a href="https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit/browse" target="_blank" rel="noopener">Bukkit</a> 这里找到 Bukkit 的源码。拿到源码后我们从 <code>registerEvents</code> 这里入手，看看它帮我们干了什么不可描述的事情。<code>PluginManager</code> 是个接口，需要到它的实现类 <code>SimplePluginManager</code> 中找。</p><pre><code class="java">public void registerEvents(Listener listener, Plugin plugin) {        //...省略那个插件是否启用的判断       for (Map.Entry&lt;Class&lt;? extends Event&gt;, Set&lt;RegisteredListener&gt;&gt; entry :        plugin.getPluginLoader().createRegisteredListeners(listener, plugin).entrySet()) {           getEventListeners(getRegistrationClass(entry.getKey()))           .registerAll(entry.getValue());       }   }</code></pre><p>可以看到这的关键就是掉了 <code>createRegisteredListeners</code> 这个方法，然后把 <code>RegisteredListeners</code> 和 <code>Event</code> 对应交给 <code>HandlerList</code> 处理。<code>createRegisteredListeners</code> 这玩意是 <code>PluginLoader</code> 接口的方法，同样，我们需要找他的实现类 <code>JavaPluginLoader</code>。这个方法有 87 行，贴出来太占地，我大概说一下他干了啥：</p><ul><li><p>拿到 <code>Listener</code> 实例后，用反射找里面的 Method</p></li><li><p>找到 Method 后检验是否符合注册的标准，并且拿到其注解 <code>@EventHandler</code> 中的优先级</p></li><li><p>对于被标注 <code>@Deprecated</code> 并符合要求的方法要在 logger 中打印出来，告诉你已经过时了</p></li><li><p>建立一个 <code>EventExecutor</code> 接口的匿名类实例，将方法 <code>execute</code> 重写，在其中调用反射找来的方法 (<code>method.invoke(listener, event)</code>)</p></li><li><p>根据 <code>useTimings</code> 分别new 出 <code>TimedRegisteredListener</code> 或 <code>RegisteredListener</code>，并把它们加到与 <code>Event</code> 对应的 Map 中</p></li></ul><p>交给 <code>HandlerList</code> 后，其中有一个 <code>EnumMap&lt;EventPriority, ArrayList&lt;RegisteredListener&gt;&gt;</code> 来保存每一个优先级对应的监听器，在 <code>PluginManager</code> 的 <code>fireEvent</code> 方法中调用。看到这我们大概了解了它的注册原理，<code>EventExecutor</code> 这个东西才是最关键的。我们回到 <code>PluginManager</code>，除了有 <code>registerEvents(Listener listener, Plugin plugin)</code> 外，还有两个注册方法：</p><pre><code class="java">public void registerEvent(Class&lt;? extends Event&gt; event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin) {       registerEvent(event, listener, priority, executor, plugin, false);   }   public void registerEvent(Class&lt;? extends Event&gt; event, Listener listener, EventPriority priority, EventExecutor executor, Plugin plugin, boolean ignoreCancelled) {       Validate.notNull(listener, &quot;Listener cannot be null&quot;);       Validate.notNull(priority, &quot;Priority cannot be null&quot;);       Validate.notNull(executor, &quot;Executor cannot be null&quot;);       Validate.notNull(plugin, &quot;Plugin cannot be null&quot;);       if (!plugin.isEnabled()) {           throw new IllegalPluginAccessException(&quot;Plugin attempted to register &quot; + event + &quot; while not enabled&quot;);       }       if (useTimings) {           getEventListeners(event).register(new TimedRegisteredListener(listener, executor, priority, plugin, ignoreCancelled));       } else {           getEventListeners(event).register(new RegisteredListener(listener, executor, priority, plugin, ignoreCancelled));       }   }</code></pre><p>对比一下刚才的 <code>registerEvents</code> ，我们发现它只是少了用反射找那些 method 的部分，并且让我们传入一个 <code>EventExecutor</code> 实例。这就很简单了，不过我一直没想明白为啥它还要求一个 <code>Listener</code> 实例。。。但是这不重要，传个空的就好，反正在 <code>RegisteredListener</code> 构造时也没有对 <code>Listener</code> 做出什么不可描述的事情。试着用一下：</p><pre><code class="kotlin">pluginManager.registerEvent(PlayerJoinEvent::class.java, object : Listener {},                EventPriority.NORMAL,                { _: Listener, e: Event -&gt; (e as PlayerJoinEvent).player sendMessage &quot;你好！&quot; },                plugin        )</code></pre><p>这里第三个参数应该是 <code>EventExecutor</code>，但此接口符合函数式接口的标准，kotlin 帮我们 SAM 转换成 <code>(Listener,Event)-&gt;Unit</code>。写好后放到服务器里运行，发现插件可以正常工作，下面就可以开始写 DSL 语言结构了。</p><h2 id="DSL-构造事件监听器"><a href="#DSL-构造事件监听器" class="headerlink" title="DSL 构造事件监听器"></a>DSL 构造事件监听器</h2><p>与上篇说的命令相似，我们同样需要把监听器封装一下，让他持有注册时所需要的参数：</p><pre><code class="kotlin">data class PackingEvent&lt;in T : Event&gt;(private val type: Class&lt;out Event&gt;,                                      private val eventPriority: EventPriority,                                      private val block: (T) -&gt; Unit) {    @Suppress(&quot;UNCHECKED_CAST&quot;)    fun register() {        pluginManager.registerEvent(type, emptyListener, eventPriority,                { _: Listener, event -&gt;                    block(event as T)                }, plugin)    }}</code></pre><p>kotlin 可以写个数据类，不过没什么卵用。因为我们传进去的是空 <code>Listener</code>，所以没必要再把一个空的拿回来。用泛型 cast 一下，不用担心 cast 出错，因为你注册的是什么事件，传进来的一定是你想要的事件。有了 <code>PackingEvent</code>，就可以创造 Builder 了。但我们发现，与命令不同，注册事件没有那些可有可无的东西，并且只需要优先级和一个 <code>(T) -&gt; Unit</code>。这样就没有必要再写 Builder 了，直接写个 Scope：</p><pre><code class="kotlin">class EventScope {    inline fun &lt;reified T : Event&gt; event(eventPriority: EventPriority = EventPriority.NORMAL, noinline block: T.() -&gt; Unit) {        PackingEvent(T::class.java, eventPriority, block).let(EventHolder::add)    }}</code></pre><p>只有一个函数，为了获取泛型的类实例，要写成 inline + reified，但又要把 <code>(T) -&gt; Unit</code>，存起来，所以 <code>block</code> 要加上关键字 <code>noinline</code>，被编译器优化后，不会创建实例。</p><pre><code>再把 Scope 开放出来：```kotlinfun buildEvents(block: EventScope.() -&gt; Unit) =    EventScope().block()</code></pre><p>然后就可以愉快的食用了，在插件启动时写上：</p><pre><code class="kotlin">buildEvents {    event&lt;PlayerJoinEvent&gt;(EventPriority.HIGH) {        player.sendMessage(ChatColor.GREEN+&quot;欢迎加入!~&quot;)    }    event&lt;PlayerBedLeaveEvent&gt; {        //xxx    }}</code></pre><p><code>event</code> 函数中直接写成了 <code>T.() -&gt; Unit</code> 并且 <code>apply(block)</code> 这个大括号的里面就相当于对应事件的类中，可以直接访问里面的公共成员。优先级上面定义了如果不声明默认是 <code>NORMAL</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说完了，就酱。垃圾代码 x2</p>]]></content>
      
      <categories>
          
          <category> Minecraft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Minecraft-Bukkit插件-DSL注册命令</title>
      <link href="/2018/01/30/minecraft-dsl-command/"/>
      <url>/2018/01/30/minecraft-dsl-command/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在食用本文前你需要了解 Kotlin语言，及用到的特性——带接收者的 lambda、内联 reified 泛型函数、扩展函数、中缀函数等。当然这些大部分都是在 Kotlin 中想要写出 DSL 语言结构的必要知识。</p><h2 id="DSL-构造命令"><a href="#DSL-构造命令" class="headerlink" title="DSL 构造命令"></a>DSL 构造命令</h2><p>关于注册命令的写法大部分都是远古判断法或者注解反射法。关于注解反射这个东西，虽然很简洁美观，但我个人是不喜欢的。就好比你追一个人一样，你不主动找人家，等着人家来遍历你，还得各种检测你。<del>(误)</del>  废话不说了，从 <code>CommandMap</code> 注册命令开始入手。<br>首先需要拿到 <code>CommandMap</code>，它位于 <code>Server</code> 类中。</p><pre><code class="kotlin">fun getCommandMap(): CommandMap =        Bukkit.getServer().let {            it::class.java.declaredMethods.firstOrNull { it.name == &quot;getCommandMap&quot; }                    ?.invoke(it) as CommandMap        }</code></pre><p>此处没有对非空做出处理，因为我们知道 <code>Server</code> 类中肯定是存在这个东西的。之后我们就要把抽象类 <code>Command</code> 给实现一下他的  <code>execute</code> 方法。在构造 DSL 过程中，我们把这个方法中执行的内容封装成一个 lambda <code>(CommandSender, String, Array&lt;out String&gt;) -&gt; Unit</code>，用<code>result</code> 作为最终返回结果。我们定义一个类来继承 <code>Command</code> 并承载这些东西。</p><pre><code class="kotlin">class PackingCommand(name: String, description: String, usageMessage: String, aliases: List&lt;String&gt;, private val action: (CommandSender, String, Array&lt;out String&gt;) -&gt; Unit, private val result: Boolean) : Command(name, description, usageMessage, aliases){   override fun execute(p0: CommandSender, p1: String, p: Array&lt;out String&gt;) =      result.apply { action(p0, p1, p) } }</code></pre><p>定义完了 <code>PackingCommand</code> 后，就该写他的 DSL Builder 了。代码如下：</p><pre><code class="kotlin">class CommandBuilderDsl(val name: String) {    //下面这些成员都带有默认值，因为每项不是必要的，包括 `action`。    var action: (CommandSender, String, Array&lt;out String&gt;) -&gt; Unit =      { _, _, _ -&gt; true }        private set   //不让在外面修改，只能通过提供的函数赋值。    var description: String = &quot;&quot;    var usageMessage: String = &quot;&quot;    val aliases: MutableList&lt;String&gt; = mutableListOf()    var result: Boolean = true    fun action(block: (CommandSender, String, Array&lt;out String&gt;) -&gt; Unit) {        action = block    }    //这里多提供一种赋值方法，因为 `label` 和 `args` 有时候不需要使用，每次都要写     `{ sender, _, _ -&gt; }` 太麻烦。    fun action(block: (CommandSender) -&gt; Unit) {        action = { sender, _, _ -&gt; block(sender) }    }    fun addAlias(alias: String) = aliases.add(alias)}</code></pre><p>写完 <code>CommandBuilderDsl</code> 后还需要提供一另一个 <code>CommandScope</code> 来构造 <code>Builder</code>，在这之前构造好的 <code>Command</code> 需要存起来，在插件启用时调用，这部分不贴代码了，就是一个<code>MutableList&lt;PackingCommand&gt;</code>，有个注册方法。<code>CommandScope</code> 的代码如下：</p><pre><code class="kotlin">class CommandScopeDsl {    fun command(name: String, block: CommandBuilderDsl.() -&gt; Unit) {        CommandBuilderDsl(name).apply(block).apply {            PackingCommand(this.name, description, usageMessage, aliases, action, result)                    .let(CommandHolder::add)        }    }}</code></pre><p>目前 <code>CommandScope</code> 中就一个函数，也可以省略 <code>CommandScope</code>，直接将 <code>command()</code> 改为顶层函数，不过未来肯定还会加东西，而且这样写是不合理的。贴一下前面的注册方法，<code>commands</code> 是那个持有 <code>PackingCommand</code> 的 list：</p><pre><code class="kotlin">fun register(commandMap: CommandMap) {        commands.forEach {            commandMap.register(&quot;DemoPlugin&quot;, it as Command)        }    }</code></pre><p>再加上把 <code>CommandScope</code> 开放出来的函数：</p><pre><code class="kotlin">fun buildCommands(block: CommandScope.() -&gt; Unit) {    CommandScope().apply(block)}</code></pre><p>至此就完成了，在插件启用时调用 <code>CommandHolder.register(getCommandMap())</code> 注册就好。<br>随便写个命令：</p><pre><code class="kotlin">buildCommands {    command(&quot;gg&quot;) {        action { sender -&gt;            sender.sendMessage(&quot;233&quot;)            true        }    }    command(&quot;xxx&quot;){        action{sender-&gt;            //xxxx        }    }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令多了看起来很乱，大括号也越写越多，垃圾代码 x1</p>]]></content>
      
      <categories>
          
          <category> Minecraft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于System.getCurrentMillis()</title>
      <link href="/2018/01/15/currentMillis/"/>
      <url>/2018/01/15/currentMillis/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java 程序开发时，我们可以用 <code>Date</code>、<code>Calendar</code> 等类获取日期来计算时间。我们通常使用 <code>System.currentTimeMillis()</code> 的时戳，来快速获取时间差，单位为毫秒。</p><blockquote><p><strong><code>System.currentTimeMillis()</code> 这玩意返回的是 <code>long</code> 类型的数据，但是数据都是有最大值的啊，万一哪天超了可咋整。</strong></p></blockquote><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>超肯定是会超，但是啥时候超我们可以简单算上一笔。<br>前方使用 Mathematica 计算。（因为单位换算太麻烦了，偷点懒。）</p><hr><p>首先，<code>long</code> 数据类型的最大值正是 <code>2^63-1</code>。这就不过多解释了。一毫秒是 <code>1/1000</code> 秒，一秒是<code>1/3600</code>时，一时是<code>1/24</code>天。知道这些我们就可以算出 <code>long</code> 最多能存多少天的毫秒。</p><pre><code class="wolfram">longMaxValue = 2^63 - 1millisecondsPerDay = 1000*60*60*24daysLongCanStorage = Quantity[longMaxValue/millisecondsDay, &quot;Days&quot;]</code></pre><p><code>Quantity[]</code> 将单位变成天数。</p><pre><code class="wolfram">remainderDays = daysLongCanStorage + DateDifference[DateObject[{1970, 1, 1}]]</code></pre><p>这个毫秒数是从 <code>1970年1月1日</code> 开始计的，所以用 <code>DateDifference[]</code> 算出那个时候与现在的天数差。再用上面算好的一共能存多少天数<strong>加</strong>上这个差，就能算出还剩多少天。因为<em>从 <code>1970年1月1日</code> 到现在的天数差是个负数。</em><br>这样就算出了还能存多少天 <code>remainderDays</code>。光知道天没有概念，得把他换算成我们这种菜鸡能一眼看出来的数据。</p><pre><code class="wolfram">UnitConvert[remainderDays, MixedRadix[&quot;Years&quot;, &quot;Months&quot;, &quot;Days&quot;, &quot;Hours&quot;, &quot;Minutes&quot;, &quot;Seconds&quot;]]</code></pre><p>输出结果为：</p><pre><code class="wolfram">Quantity[MixedMagnitude[{292471160, 7, 7, 12, 8, 58.2528}], MixedUnit[{&quot;Years&quot;, &quot;Months&quot;, &quot;Days&quot;, &quot;Hours&quot;, &quot;Minutes&quot;,   &quot;Seconds&quot;}]]</code></pre><p>也就是 <code>292471160年7月7日12时8分58.2528秒</code>。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之这玩意还能存这么久，想要活那么长时间不太可能，不过那时候没准人类早已入土，更别说 <code>Java</code> 了。<br>贴上全部代码：</p><pre><code class="wolfram">In[0]:=longMaxValue = 2^63 - 1      millisecondsDay = 1000*60*60*24      daysLongCanStorage = Quantity[longMaxValue/millisecondsDay,&quot;Days&quot;]      remainderDays = daysLongCanStorage + DateDifference[DateObject[{1970, 1, 1}]]      UnitConvert[remainderDays,      MixedRadix[&quot;Years&quot;, &quot;Months&quot;, &quot;Days&quot;, &quot;Hours&quot;, &quot;Minutes&quot;, &quot;Seconds&quot;]]Out[0]:= 9223372036854775807Out[1]:= 86400000Out[2]:= Quantity[9223372036854775807/86400000, &quot;Days&quot;]Out[3]:= Quantity[1.06752*10^11, &quot;Days&quot;]Out[4]:= Quantity[MixedMagnitude[{292471160, 7, 7, 12, 8, 58.2528}],            MixedUnit[{&quot;Years&quot;, &quot;Months&quot;, &quot;Days&quot;, &quot;Hours&quot;, &quot;Minutes&quot;, &quot;Seconds&quot;}]]</code></pre><p><strong>顺便在这天来临之前的 <code>292471160年7月7日12时8分58.2528秒</code> 留个脚印。</strong></p>]]></content>
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<pre><code class="kotlin">val berberman = Boy().apply{  name = &quot;berberman&quot;  location = Location.Beijing  contacts.putAll(hashMapOf(    &quot;Email&quot; to &quot;potato@berberman.cn&quot;,    &quot;Telegram&quot; to &quot;@berberman&quot;    ))}</code></pre><h2 id="何人甚于鄙之鶸乎"><a href="#何人甚于鄙之鶸乎" class="headerlink" title="何人甚于鄙之鶸乎"></a><strong>何人甚于鄙之鶸乎</strong></h2>]]></content>
    </entry>
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
